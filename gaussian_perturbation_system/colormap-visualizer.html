<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Colormap Visualizer</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-axis.v1.min.js"></script>
    <script src="https://d3js.org/d3-fetch.v1.min.js"></script>
    
    <!-- Static Metrics Dependencies -->
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/design/lib/d3-interpolate.v1.min.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/design/lib/d3-cam02.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/design/lib/d3-color.v1.min.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/src/scalar.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/design/src/colormap.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/design/src/gl_pipeline.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/design/src/coloranalysis.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/design/src/scalarvis.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/lib/colorname/c3.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/src/perlin.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/src/noisegen.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; }
        
        .container {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: 100vh;
            gap: 0;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            background: white;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #ddd;
        }
        
        h2 { 
            font-size: 18px; 
            margin-bottom: 15px; 
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }
        
        h3 {
            font-size: 14px;
            margin: 15px 0 10px 0;
            color: #666;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            font-size: 13px;
            margin-bottom: 5px;
            color: #555;
        }
        
        select, input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 13px;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .value-display {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            font-weight: bold;
            color: #4CAF50;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin-top: 10px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .btn-primary:hover {
            background: #45a049;
        }
        
        .btn-secondary {
            background: #2196F3;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #0b7dda;
        }
        
        /* å¯è§†åŒ–åŒºåŸŸ */
        .visualization-area {
            padding: 20px;
            overflow-y: auto;
            max-width: 1200px;
        }
        
        .colormap-display {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .colormap-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
        
        canvas {
            display: block;
            margin: 10px 0;
        }
        
        .stats-box {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 15px;
            border-left: 4px solid #4CAF50;
        }
        
        .stats-box p {
            margin: 5px 0;
            font-size: 13px;
            color: #666;
        }
        
        .stats-box strong {
            color: #333;
        }
        
        .preset-btn {
            padding: 8px;
            margin: 5px 5px 5px 0;
            font-size: 12px;
            display: inline-block;
            width: auto;
        }
        
        .chart-container {
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <h2>ğŸ¨ Colormap Generator</h2>
            
            <!-- Hueæ§åˆ¶ -->
            <div class="control-group">
                <h3>Hue (è‰²ç›¸)</h3>
                <label>Hue Range:</label>
                <select id="hue-range">
                    <option value="100">100Â° </option>
                    <option value="200" selected>200Â° </option>
                    <option value="300">300Â° </option>
                </select>
                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                    è‰²ç›¸è·¨åº¦ï¼šèµ·å§‹ç‚¹å°†è‡ªåŠ¨æœç´¢
                </div>
            </div>
            
            <!-- Chromaæ§åˆ¶ -->
            <div class="control-group">
                <h3>Chroma (é¥±å’Œåº¦)</h3>
                <label>Pattern:</label>
                <select id="chroma-pattern">
                    <option value="uniform">Uniform (æ’å®š)</option>
                    <option value="linear" selected>Linear (çº¿æ€§)</option>
                    <option value="peak">Peak (æ³¢å³°)</option>
                    <option value="valley">Valley (æ³¢è°·)</option>
                    <option value="wave">Wave (æ³¢åŠ¨)</option>
                </select>
                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                    Min/Max å°†è‡ªåŠ¨æœç´¢æœ€ä¼˜å€¼
                </div>
            </div>
            
            <!-- Luminanceæ§åˆ¶ -->
            <div class="control-group">
                <h3>Luminance (äº®åº¦)</h3>
                <label>Pattern:</label>
                <select id="lumi-pattern">
                    <option value="uniform">Uniform (æ’å®š)</option>
                    <option value="linear" selected>Linear (çº¿æ€§)</option>
                    <option value="peak">Peak (æ³¢å³°)</option>
                    <option value="valley">Valley (æ³¢è°·)</option>
                    <option value="wave">Wave (æ³¢åŠ¨)</option>
                </select>
                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                    Min/Max å°†è‡ªåŠ¨æœç´¢æœ€ä¼˜å€¼
                </div>
            </div>
            
            <!-- Î”E å‚æ•°æ§åˆ¶ -->
            <div class="control-group">
                <h3>Î”E Parameters (å¯è¾¨è¯†æ€§)</h3>
                <label>Sample Points (é‡‡æ ·ç‚¹):</label>
                <input type="number" id="delta-e-samples" value="10" min="3" max="50" step="1">
                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                    ç”¨äºè®¡ç®—è‰²å·®çš„é‡‡æ ·ç‚¹æ•°é‡
                </div>
                
                <label style="margin-top: 10px;">Î”E Threshold (é˜ˆå€¼):</label>
                <input type="number" id="delta-e-threshold" value="3" min="1" max="10" step="0.5">
                <div style="font-size: 11px; color: #999; margin-top: 5px;">
                    ç›¸é‚»é¢œè‰²çš„æœ€å°å¯è¾¨è¯†è‰²å·® (é»˜è®¤: 3)
                </div>
            </div>
            
            <!-- ç”Ÿæˆæ¨¡å¼ -->
            <div class="control-group">
                <h3>Generation Mode</h3>
                <label>
                    <input type="radio" name="gen-mode" value="strict" checked> 
                    Strict (æ— çªå˜)
                </label>
                <br>
                <label>
                    <input type="radio" name="gen-mode" value="adjusted"> 
                    Adjusted (å…è®¸ä¿®æ­£)
                </label>
                
                <div id="strict-options" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px;">
                    <div style="font-size: 11px; color: #666; padding: 5px; background: #e8f5e9; border-radius: 3px; border-left: 3px solid #4CAF50;">
                        âš¡ <strong>æ™ºèƒ½æœç´¢å¼€å¯</strong><br>
                        ç³»ç»Ÿå°†è‡ªåŠ¨å¯»æ‰¾æœ€æ¥è¿‘ç›®æ ‡èŒƒå›´çš„æœ‰æ•ˆç»“æœ (æ­¥é•¿=5)
                    </div>
                    <!-- éšè—çš„æ§ä»¶ (é€»è¾‘é»˜è®¤å¼€å¯) -->
                    <input type="checkbox" id="adaptive-range" checked style="display: none;"> 
                </div>
            </div>
            
            <!-- ç”ŸæˆæŒ‰é’® -->
            <button class="btn-primary" onclick="generateColormap()">ğŸ¨ Generate Colormap</button>
            <button class="btn-secondary" onclick="exportColormap()">ğŸ’¾ Export JSON</button>
        </div>
        
        <!-- å¯è§†åŒ–åŒºåŸŸ -->
        <div class="visualization-area" id="viz-area">
            <div style="text-align: center; padding: 100px 20px; color: #999;">
                <h2>ğŸ‘ˆ Configure parameters and click Generate</h2>
                <p style="margin-top: 10px;">è°ƒæ•´å·¦ä¾§å‚æ•°åç‚¹å‡»ç”ŸæˆæŒ‰é’®</p>
            </div>
        </div>
    </div>

<script>
// ========== æ ¸å¿ƒç®—æ³•éƒ¨åˆ†ï¼ˆä»stimuli-generator.htmlä¿æŒä¸å˜ï¼‰==========

// CIEDE2000è‰²å·®è®¡ç®—
function ciede2000(lab1, lab2) {
    const [L1, a1, b1] = lab1;
    const [L2, a2, b2] = lab2;

    const avg_L = (L1 + L2) / 2.0;
    const C1 = Math.sqrt(a1 * a1 + b1 * b1);
    const C2 = Math.sqrt(a2 * a2 + b2 * b2);
    const avg_C = (C1 + C2) / 2.0;

    const G = 0.5 * (1 - Math.sqrt((avg_C ** 7) / ((avg_C ** 7) + (25 ** 7))));
    const a1p = (1 + G) * a1;
    const a2p = (1 + G) * a2;
    const C1p = Math.sqrt(a1p * a1p + b1 * b1);
    const C2p = Math.sqrt(a2p * a2p + b2 * b2);

    const avg_Cp = (C1p + C2p) / 2.0;

    const h1 = Math.atan2(b1, a1p), h2 = Math.atan2(b2, a2p);
    const h1p = h1 * 180 / Math.PI + (h1 < 0 ? 360 : 0);
    const h2p = h2 * 180 / Math.PI + (h2 < 0 ? 360 : 0);

    const deltahp = (C1p * C2p === 0) ? 0 :
        (Math.abs(h2p - h1p) <= 180) ? (h2p - h1p) :
            (h2p <= h1p) ? (h2p - h1p + 360) : (h2p - h1p - 360);

    const deltaLp = L2 - L1;
    const deltaCp = C2p - C1p;
    const deltaHp = 2 * Math.sqrt(C1p * C2p) * Math.sin((deltahp * Math.PI) / 360);

    const avg_Lp = (L1 + L2) / 2.0;
    let avg_hp;
    if (Math.abs(h1p - h2p) <= 180) {
        avg_hp = (h1p + h2p) / 2.0;
    } else if ((h1p + h2p) < 360) {
        avg_hp = (h1p + h2p + 360) / 2.0;
    } else {
        avg_hp = (h1p + h2p - 360) / 2.0;
    }

    const T = 1
        - 0.17 * Math.cos((avg_hp - 30) * Math.PI / 180)
        + 0.24 * Math.cos((2 * avg_hp) * Math.PI / 180)
        + 0.32 * Math.cos((3 * avg_hp + 6) * Math.PI / 180)
        - 0.20 * Math.cos((4 * avg_hp - 63) * Math.PI / 180);

    const delta_ro = 30 * Math.exp(-(((avg_hp - 275) / 25) ** 2));
    const RC = 2 * Math.sqrt((avg_Cp ** 7) / ((avg_Cp ** 7) + (25 ** 7)));
    const SL = 1 + (0.015 * ((avg_Lp - 50) ** 2)) / Math.sqrt(20 + ((avg_Lp - 50) ** 2));
    const SC = 1 + 0.045 * avg_Cp;
    const SH = 1 + 0.015 * avg_Cp * T;
    const RT = -Math.sin(2 * delta_ro * Math.PI / 180) * RC;

    const deltaE = Math.sqrt(
        (deltaLp / SL) ** 2 +
        (deltaCp / SC) ** 2 +
        (deltaHp / SH) ** 2 +
        RT * (deltaCp / SC) * (deltaHp / SH)
    );

    return deltaE;
}

function getInterpolatedValues(arr, num) {
    const step_num = 500;
    let interpolated = [];
    for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < step_num; j++) {
            const t = j / step_num;
            interpolated.push(arr[i] + t * (arr[i + 1] - arr[i]));
        }
    }
    interpolated.push(arr[arr.length - 1]);
    
    const sampled = [];
    for (let i = 0; i < num; i++) {
        const idx = Math.round(i / (num - 1) * (interpolated.length - 1));
        sampled.push(interpolated[idx]);
    }
    return sampled;
}

function getInterpolatedHues(hue_points, num) {
    let interpolated = [];
    const step_num = 500;
    
    for (let i = 0; i < hue_points.length - 1; i++) {
        const h1 = hue_points[i];
        const h2 = hue_points[i + 1];
        let hue;
        
        for (let j = 0; j < step_num; j++) {
            if (h2 < h1)
                hue = (h1 + (h2 - h1) * j / step_num) % 360;
            else
                hue = (h1 + (h2 - h1 - 360) * j / step_num + 360) % 360;
            interpolated.push(hue);
        }
    }
    
    interpolated.push(hue_points[hue_points.length - 1]);
    
    const sampled = [];
    for (let i = 0; i < num; i++) {
        const idx = Math.round(i / (num - 1) * (interpolated.length - 1));
        sampled.push(interpolated[idx]);
    }
    
    return sampled;
}

const perturbOffsets = [];
for (let i = -10; i <= 10; i++) {
    for (let j = -30; j <= 30; j++) {
        for (let k = -30; k <= 30; k++) {
            perturbOffsets.push([i, j, k]);
        }
    }
}
perturbOffsets.sort((a, b) => Math.hypot(...a) - Math.hypot(...b));

function findNearestValidColor([h, c, l]) {
    for (let [dh, dc, dl] of perturbOffsets) {
        const hh = (h + dh + 360) % 360;
        const cc = Math.max(0, Math.min(120, c + dc));
        const ll = Math.max(10, Math.min(90, l + dl));
        const rgb = d3.hcl(hh, cc, ll).rgb();
        if (rgb.displayable()) {
            return [hh, cc, ll];
        }
    }
    return [h, c, l];
}

// ========== UIäº¤äº’éƒ¨åˆ† ==========

let currentColormap = null;
let currentStats = null;

// åˆå§‹åŒ–æ»‘å—å€¼æ˜¾ç¤º
document.querySelectorAll('input[type="range"]').forEach(slider => {
    const valueId = slider.id + '-val';
    const valueSpan = document.getElementById(valueId);
    if (valueSpan) {
        slider.addEventListener('input', (e) => {
            valueSpan.textContent = e.target.value;
        });
    }
});

// è®¡ç®—è‰²å·®ç»Ÿè®¡
function calculateDeltaEStats(colormap, sampleNum = 10, threshold = 3) {
    const sampled = [];
    for (let i = 0; i < colormap.length; i += Math.floor(colormap.length / sampleNum)) {
        const lab = d3.lab(colormap[i]);
        sampled.push([lab.l, lab.a, lab.b]);
    }
    
    const deltaEs = [];
    for (let i = 0; i < sampled.length - 1; i++) {
        deltaEs.push(ciede2000(sampled[i], sampled[i + 1]));
    }
    
    return {
        min: Math.min(...deltaEs),
        max: Math.max(...deltaEs),
        avg: deltaEs.reduce((a, b) => a + b, 0) / deltaEs.length,
        allPass: deltaEs.every(de => de >= threshold),
        threshold: threshold,
        sampleNum: sampleNum
    };
}

function getPatternControlPoints(pattern, min, max, value = null) {
    const mid = value !== null ? value : (min + max) / 2;
    switch(pattern) {
        case 'uniform':
            return [mid, mid];
        case 'linear':
            return [min, max];
        case 'peak':
            return [min, max, min];
        case 'valley':
            return [max, min, max];
        case 'wave':
            return [min, max, min, max, min];
        default:
            return [min, max];
    }
}

// å®šä¹‰æœç´¢å‚æ•°ç©ºé—´ï¼ˆChroma å’Œ Luminanceï¼‰
const SEARCH_SPACE = {
    chromaRanges: [
        [20, 60], [20, 80], [20, 100], [20, 120],
        [30, 80], [30, 100],
        [40, 100], [40, 120]
    ],
    lumiRanges: [
        [20, 50], [20, 70], [20, 90],
        [25, 65], [25, 85],
        [30, 70], [30, 90]
    ]
};

// ç»‘å®šæ¨¡å¼åˆ‡æ¢äº‹ä»¶
document.querySelectorAll('input[name="gen-mode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        const strictOptions = document.getElementById('strict-options');
        strictOptions.style.display = e.target.value === 'strict' ? 'block' : 'none';
    });
});

function generateColormap() {
    // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
    currentColormap = [];
    currentStats = {};
    document.getElementById('viz-area').innerHTML = '';
    
    const genMode = document.querySelector('input[name="gen-mode"]:checked').value;
    
    if (genMode === 'strict') {
        generateColormapStrict();
    } else {
        generateColormapAdjusted();
    }
}

// ä¸¥æ ¼æ¨¡å¼ï¼šè‡ªåŠ¨æœç´¢å‚æ•°ç©ºé—´
function generateColormapStrict() {
    const sampleNum = 256;
    
    // è¯»å–ç”¨æˆ·é€‰æ‹©çš„å‚æ•°
    const hueRange = parseInt(document.getElementById('hue-range').value);
    const chromaPattern = document.getElementById('chroma-pattern').value;
    const lumiPattern = document.getElementById('lumi-pattern').value;
    const deltaESamples = parseInt(document.getElementById('delta-e-samples').value);
    const deltaEThreshold = parseFloat(document.getElementById('delta-e-threshold').value);
    
    // éšæœºç”Ÿæˆhueèµ·ç‚¹
    const randomHueStart = Math.random() * 360;
    console.log('ğŸ” Starting intelligent parameter space search...');
    console.log('Hue Range:', hueRange + 'Â°', '(Random Start:', randomHueStart.toFixed(1) + 'Â°)');
    console.log('Chroma Pattern:', chromaPattern);
    console.log('Luminance Pattern:', lumiPattern);
    console.log('Î”E Samples:', deltaESamples, 'Threshold:', deltaEThreshold);
    
    // å›ºå®šä½¿ç”¨æœ€å°æ­¥é•¿è¿›è¡Œç²¾ç¡®æœç´¢
    const hueSearchStep = 5;
    const baseSearchStep = 5;
    const huePointsNum = 2;  // å›ºå®šä½¿ç”¨2ä¸ªæ§åˆ¶ç‚¹ï¼ˆèµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
    
    let bestResult = null;
    let totalCombinations = SEARCH_SPACE.chromaRanges.length * 
                           SEARCH_SPACE.lumiRanges.length;
    let testedCombinations = 0;
    
    console.log(`ğŸ“Š Total parameter combinations: ${totalCombinations}`);
    
    // éå†å‚æ•°ç©ºé—´ï¼ˆChroma å’Œ Luminanceï¼‰
    outerLoop: for (const [chromaMin, chromaMax] of SEARCH_SPACE.chromaRanges) {
        for (const [lumiMin, lumiMax] of SEARCH_SPACE.lumiRanges) {
            testedCombinations++;
            
            if (testedCombinations % 10 === 0 || testedCombinations === 1) {
                console.log(`â±ï¸ Testing combination ${testedCombinations}/${totalCombinations}: Hue=${hueRange}Â°, C=[${chromaMin},${chromaMax}], L=[${lumiMin},${lumiMax}]`);
            }
            
            // æ ¹æ® pattern ç”Ÿæˆæ§åˆ¶ç‚¹
            const chromaValue = chromaPattern === 'uniform' ? (chromaMin + chromaMax) / 2 : null;
            const lumiValue = lumiPattern === 'uniform' ? (lumiMin + lumiMax) / 2 : null;
            
            const chromaControls = getPatternControlPoints(chromaPattern, chromaMin, chromaMax, chromaValue);
            const lumiControls = getPatternControlPoints(lumiPattern, lumiMin, lumiMax, lumiValue);
            
            let targetC = chromaMax - chromaMin;
            let targetL = lumiMax - lumiMin;
            
            // ä½¿ç”¨æ‰°åŠ¨ç­–ç•¥è¿›ä¸€æ­¥ä¼˜åŒ–
            const perturbOffsets = generatePerturbOffsets(targetC, targetL);
            
            for (let i = 0; i < perturbOffsets.length && i < 20; i++) { // æœ€å¤šå°è¯•20ä¸ªæ‰°åŠ¨
                const [cOffset, lOffset] = perturbOffsets[i];
                const usedC = Math.max(10, targetC - cOffset);
                const usedL = Math.max(10, targetL - lOffset);
                
                const candidates = searchValidColormaps(
                    sampleNum, hueRange, huePointsNum,
                    chromaPattern, chromaValue, usedC, chromaControls,
                    lumiPattern, lumiValue, usedL, lumiControls,
                    hueSearchStep, baseSearchStep,
                    randomHueStart, deltaESamples, deltaEThreshold
                );
                
                if (candidates.length > 0) {
                    // æ‰¾åˆ°å¯è¡Œè§£
                    candidates.sort((a, b) => {
                        const errA = Math.abs(a.cRange[1] - a.cRange[0] - targetC) + 
                                     Math.abs(a.lRange[1] - a.lRange[0] - targetL);
                        const errB = Math.abs(b.cRange[1] - b.cRange[0] - targetC) + 
                                     Math.abs(b.cRange[1] - b.cRange[0] - targetL);
                        return errA - errB;
                    });
                    
                    bestResult = {
                        candidate: candidates[0],
                        hueRange, chromaMin, chromaMax, lumiMin, lumiMax,
                        chromaValue, lumiValue,
                        usedC, usedL,
                        attempts: i + 1,
                        combinationIndex: testedCombinations
                    };
                    
                    console.log(`âœ… Found valid colormap at combination ${testedCombinations}/${totalCombinations}!`);
                    console.log(`   Parameters: Hue=${hueRange}Â°, C=[${chromaMin},${chromaMax}], L=[${lumiMin},${lumiMax}]`);
                    break outerLoop; // æ‰¾åˆ°å°±ç«‹å³åœæ­¢æ‰€æœ‰æœç´¢
                }
            }
        }
    }
    
    if (!bestResult) {
        const suggestions = [
            '1. å°è¯•ä¸åŒçš„ Hue Range (100Â°/200Â°/300Â°)',
            '2. å°è¯•ä¸åŒçš„ Pattern ç»„åˆ',
            '3. å°è¯• Adjusted æ¨¡å¼ (å¦‚æœåªéœ€è¦å¿«é€Ÿç»“æœ)'
        ];
        alert('âš ï¸ æ— æ³•æ‰¾åˆ°å®Œå…¨åœ¨è‰²åŸŸå†…çš„colormapï¼\n\nå»ºè®®ï¼š\n' + suggestions.join('\n'));
        console.log(`âŒ No valid candidates found after testing ${testedCombinations} combinations`);
        
        // æ¸…ç©ºæ˜¾ç¤º
        currentColormap = [];
        currentStats = {};
        document.getElementById('viz-area').innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">æœç´¢å¤±è´¥ï¼Œè¯·è°ƒæ•´å‚æ•°åé‡è¯•</div>';
        return;
    }
    
    // ä½¿ç”¨æ‰¾åˆ°çš„æœ€ä½³ç»“æœ
    const best = bestResult.candidate;
    console.log(`âœ… Successfully found colormap!`);
    console.log('Best params:', `hStart=${best.hStart}, cBase=${best.cBase}, lBase=${best.lBase}`);
    console.log('Auto-selected ranges:', `Hue=${bestResult.hueRange}, C=[${bestResult.chromaMin},${bestResult.chromaMax}], L=[${bestResult.lumiMin},${bestResult.lumiMax}]`);
    
    currentColormap = best.colormap;
    currentStats = {
        total: sampleNum,
        invalid: 0,
        hclData: best.hclData,
        deltaE: best.deltaE,
        actualRanges: {
            chroma: best.cRange,
            luminance: best.lRange
        },
        config: {
            hueRange: hueRange,
            chromaPattern, 
            chromaMin: bestResult.chromaMin, 
            chromaMax: bestResult.chromaMax, 
            chromaValue: bestResult.chromaValue,
            lumiPattern, 
            lumiMin: bestResult.lumiMin, 
            lumiMax: bestResult.lumiMax, 
            lumiValue: bestResult.lumiValue,
            mode: 'strict',
            searchParams: { 
                hStart: best.hStart, 
                cBase: best.cBase, 
                lBase: best.lBase,
                attempts: bestResult.attempts,
                combinationsTested: bestResult.combinationIndex,
                finalTargetC: bestResult.usedC.toFixed(0),
                finalTargetL: bestResult.usedL.toFixed(0)
            }
        }
    };
    
    visualizeColormap();
}

// æœç´¢æœ‰æ•ˆçš„colormapå€™é€‰
function searchValidColormaps(
    sampleNum, hueRange, huePointsNum,
    chromaPattern, chromaValue, targetC, chromaControls,
    lumiPattern, lumiValue, targetL, lumiControls,
    hueSearchStep, baseSearchStep,
    randomHueStart, deltaESamples, deltaEThreshold
) {
    const candidates = [];
    const maxCandidates = 10;  // æ‰¾åˆ°10ä¸ªå€™é€‰å°±åœæ­¢
    
    const totalHueSteps = Math.ceil(360 / hueSearchStep);
    const totalCSteps = Math.ceil(Math.max(0, 120 - targetC) / baseSearchStep);
    const totalLSteps = Math.ceil(Math.max(10, 100 - targetL) / baseSearchStep);
    const totalIterations = totalHueSteps * totalCSteps * totalLSteps;
    
    console.log(`â±ï¸ Starting precise search (step=5)`);
    console.log(`   Total iterations: ${totalIterations} (${totalHueSteps} Ã— ${totalCSteps} Ã— ${totalLSteps})`);
    
    let iterCount = 0;
    
    // ä½¿ç”¨éšæœºèµ·ç‚¹ï¼Œåªæœç´¢è¿™ä¸€ä¸ªèµ·ç‚¹ï¼ˆä¸å†éå†æ‰€æœ‰å¯èƒ½çš„hueèµ·ç‚¹ï¼‰
    const hStart = randomHueStart;
    {
        // äºŒé‡å¾ªç¯æœç´¢ï¼ˆcBase/lBase ç”¨ baseSearchStepï¼‰
        for (let cBase = 0; cBase <= Math.max(0, 120 - targetC); cBase += baseSearchStep) {
            for (let lBase = 10; lBase <= Math.max(10, 100 - targetL); lBase += baseSearchStep) {
                iterCount++;
                
                // æ¯1000æ¬¡è¿­ä»£è¾“å‡ºè¿›åº¦
                if (iterCount % 1000 === 0) {
                    const progress = ((iterCount / totalIterations) * 100).toFixed(1);
                    console.log(`   Progress: ${progress}% (${iterCount}/${totalIterations}), Found: ${candidates.length}`);
                }
                
                // è®¡ç®— Hue ç»ˆç‚¹ï¼ˆä¸åŸç³»ç»Ÿä¸€è‡´ï¼šé€†æ—¶é’ˆæ–¹å‘ï¼‰
                const hEnd = (hStart - hueRange + 360) % 360;
                
                const colormap = [];
                const hclData = [];
                let allValid = true;
                
                for (let i = 0; i < sampleNum; i++) {
                    const t = i / (sampleNum - 1);
                    
                    // Hue æ’å€¼ï¼ˆä¸åŸç³»ç»Ÿä¸€è‡´çš„é€»è¾‘ï¼‰
                    const h1 = hStart;
                    const h2 = hEnd;
                    let h;
                    
                    // åˆ¤æ–­æ—‹è½¬æ–¹å‘å¹¶æ’å€¼
                    if (h2 < h1) {
                        h = (h1 + (h2 - h1) * t) % 360;
                    } else {
                        h = (h1 + (h2 - h1 - 360) * t + 360) % 360;
                    }
                    
                    // Chromaæ’å€¼ï¼šå½’ä¸€åŒ–åæ˜ å°„åˆ° cBase + targetC * norm
                    const cInterp = interpolateMultiSegment(t, chromaControls);
                    const cMin = Math.min(...chromaControls);
                    const cMax = Math.max(...chromaControls);
                    const cNorm = (cInterp - cMin) / Math.max(1e-5, cMax - cMin);
                    const c = chromaPattern === 'uniform' ? chromaValue : (cBase + targetC * cNorm);
                    
                    // Luminanceæ’å€¼ï¼šå½’ä¸€åŒ–åæ˜ å°„åˆ° lBase + targetL * norm
                    const lInterp = interpolateMultiSegment(t, lumiControls);
                    const lMin = Math.min(...lumiControls);
                    const lMax = Math.max(...lumiControls);
                    const lNorm = (lInterp - lMin) / Math.max(1e-5, lMax - lMin);
                    const l = lumiPattern === 'uniform' ? lumiValue : (lBase + targetL * lNorm);
                    
                    const rgb = d3.hcl(h, c, l).rgb();
                    if (!rgb.displayable()) {
                        allValid = false;
                        break;  // âŒ ä¸¥æ ¼æ¨¡å¼ï¼šåªè¦æœ‰ä¸€ä¸ªä¸å¯æ˜¾ç¤ºï¼Œæ”¾å¼ƒ
                    }
                    
                    colormap.push(rgb);
                    hclData.push([h, c, l]);
                }
                
                // åªä¿ç•™å®Œå…¨æœ‰æ•ˆçš„å€™é€‰
                if (allValid && colormap.length === sampleNum) {
                    const deltaE = calculateDeltaEStats(colormap, deltaESamples, deltaEThreshold);
                    if (deltaE.allPass) {  // è¿˜è¦æ»¡è¶³å¯è¾¨è¯†æ€§
                        const actualC = hclData.map(d => d[1]);
                        const actualL = hclData.map(d => d[2]);
                        candidates.push({
                            colormap, hclData,
                            cRange: [Math.min(...actualC), Math.max(...actualC)],
                            lRange: [Math.min(...actualL), Math.max(...actualL)],
                            deltaE,
                            hStart, cBase, lBase
                        });
                    }
                }
                
                if (candidates.length >= maxCandidates) break;
            }
            if (candidates.length >= maxCandidates) break;
        }
    }
    
    console.log(`âœ… Search completed: ${candidates.length} candidates found in ${iterCount} iterations`);
    
    return candidates;
}

// è°ƒæ•´æ¨¡å¼ï¼šå…è®¸å•ä¸ªé¢œè‰²ä¿®æ­£ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´
function generateColormapAdjusted() {
    const sampleNum = 256;
    
    // è¯»å–ç”¨æˆ·é€‰æ‹©çš„ Hue Range
    const hueRange = parseInt(document.getElementById('hue-range').value);
    const huePointsNum = 2;  // å›ºå®šä½¿ç”¨2ä¸ªæ§åˆ¶ç‚¹ï¼ˆèµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
    
    const chromaPattern = document.getElementById('chroma-pattern').value;
    let chromaMin, chromaMax, chromaValue = null;
    if (chromaPattern === 'uniform') {
        chromaValue = 65;
        chromaMin = chromaValue;
        chromaMax = chromaValue;
    } else {
        chromaMin = 20;
        chromaMax = 100;
    }
    
    const lumiPattern = document.getElementById('lumi-pattern').value;
    let lumiMin, lumiMax, lumiValue = null;
    if (lumiPattern === 'uniform') {
        lumiValue = 55;
        lumiMin = lumiValue;
        lumiMax = lumiValue;
    } else {
        lumiMin = 20;
        lumiMax = 90;
    }
    
    // éšæœºèµ·ç‚¹ï¼Œè®¡ç®—ç»ˆç‚¹ï¼ˆé€†æ—¶é’ˆæ–¹å‘ï¼‰
    const hueStart = Math.random() * 360;
    const hueEnd = (hueStart - hueRange + 360) % 360;
    
    const chromas = getInterpolatedValues(
        getPatternControlPoints(chromaPattern, chromaMin, chromaMax, chromaValue), 
        sampleNum
    );
    const lumis = getInterpolatedValues(
        getPatternControlPoints(lumiPattern, lumiMin, lumiMax, lumiValue), 
        sampleNum
    );
    
    const colormap = [];
    const hclData = [];
    let invalidCount = 0;
    
    for (let i = 0; i < sampleNum; i++) {
        const t = i / (sampleNum - 1);
        
        // Hue æ’å€¼ï¼ˆé€†æ—¶é’ˆæ–¹å‘ï¼‰
        const h1 = hueStart;
        const h2 = hueEnd;
        let h;
        if (h2 < h1) {
            h = (h1 + (h2 - h1) * t) % 360;
        } else {
            h = (h1 + (h2 - h1 - 360) * t + 360) % 360;
        }
        
        const hcl = [h, chromas[i], lumis[i]];
        const rgb = d3.hcl(...hcl).rgb();
        if (!rgb.displayable()) {
            invalidCount++;
            const adjusted = findNearestValidColor(hcl);
            hclData.push(adjusted);
            colormap.push(d3.hcl(...adjusted).rgb());
        } else {
            hclData.push(hcl);
            colormap.push(rgb);
        }
    }
    
    const actualChromaMin = Math.min(...hclData.map(d => d[1]));
    const actualChromaMax = Math.max(...hclData.map(d => d[1]));
    const actualLumiMin = Math.min(...hclData.map(d => d[2]));
    const actualLumiMax = Math.max(...hclData.map(d => d[2]));
    
    const deltaESamples = parseInt(document.getElementById('delta-e-samples').value);
    const deltaEThreshold = parseFloat(document.getElementById('delta-e-threshold').value);
    const deltaEStats = calculateDeltaEStats(colormap, deltaESamples, deltaEThreshold);
    
    currentColormap = colormap;
    currentStats = {
        total: sampleNum,
        invalid: invalidCount,
        hclData: hclData,
        deltaE: deltaEStats,
        actualRanges: {
            chroma: [actualChromaMin, actualChromaMax],
            luminance: [actualLumiMin, actualLumiMax]
        },
        config: {
            hueRange,
            chromaPattern, chromaMin, chromaMax, chromaValue,
            lumiPattern, lumiMin, lumiMax, lumiValue,
            mode: 'adjusted'
        }
    };
    
    visualizeColormap();
}

// å¤šæ®µæ’å€¼å‡½æ•°ï¼ˆä»åŸæ–‡ä»¶ï¼‰
function interpolateMultiSegment(t, points) {
    const seg = points.length - 1;
    const segT = t * seg;
    const idx = Math.floor(segT);
    const frac = segT - idx;
    const p0 = points[idx] ?? points[points.length - 1];
    const p1 = points[idx + 1] ?? points[points.length - 1];
    return (p0 + frac * (p1 - p0));
}

// ç”Ÿæˆæ‰°åŠ¨åç§»é‡ï¼ˆæ¨¡ä»¿åŸæ–‡ä»¶ç­–ç•¥ï¼‰
function generatePerturbOffsets(targetC, targetL) {
    const offsets = [];
    
    // Chroma: 0 åˆ° 70% çš„ç›®æ ‡èŒƒå›´
    const maxCOffset = Math.ceil(targetC * 0.7);
    // Luminance: 0 åˆ° 70% çš„ç›®æ ‡èŒƒå›´
    const maxLOffset = Math.ceil(targetL * 0.7);
    
    // ç”Ÿæˆæ‰€æœ‰ç»„åˆï¼ˆæ­¥é•¿5ï¼‰
    for (let i = 0; i <= maxCOffset; i += 5) {
        for (let j = 0; j <= maxLOffset; j += 5) {
            offsets.push([i, j]);
        }
    }
    
    // æŒ‰æ¬§æ°è·ç¦»æ’åºï¼ˆä¼˜å…ˆå°è¯•å°åç§»ï¼‰
    offsets.sort((a, b) => {
        const distA = Math.hypot(a[0], a[1]);
        const distB = Math.hypot(b[0], b[1]);
        return distA - distB;
    });
    
    return offsets;
}

function visualizeColormap() {
    const vizArea = document.getElementById('viz-area');
    vizArea.innerHTML = '';
    
    // 0. Config Info
    const configDiv = createConfigInfo();
    vizArea.appendChild(configDiv);
    
    // 1. Colormap Bar
    const barDiv = createColormapBar();
    vizArea.appendChild(barDiv);
    
    // 2. HCL Curves
    const curvesDiv = createHCLCurves();
    vizArea.appendChild(curvesDiv);
    
    // 3. Static Metrics (Previously section 4)
    const metricsDiv = createStaticMetricsBox();
    vizArea.appendChild(metricsDiv);
}

function createConfigInfo() {
    const div = document.createElement('div');
    div.className = 'colormap-display';
    
    const cfg = currentStats.config;
    const chromaDesc = cfg.chromaPattern === 'uniform' ? 
        `${cfg.chromaPattern} (${cfg.chromaValue})` :
        `${cfg.chromaPattern} [${cfg.chromaMin}, ${cfg.chromaMax}]`;
    const lumiDesc = cfg.lumiPattern === 'uniform' ? 
        `${cfg.lumiPattern} (${cfg.lumiValue})` :
        `${cfg.lumiPattern} [${cfg.lumiMin}, ${cfg.lumiMax}]`;
    
    const autoSelectedNote = cfg.mode === 'strict' && cfg.searchParams && cfg.searchParams.combinationsTested ? 
        `<div style="font-size: 11px; color: #4CAF50; margin-top: 8px; padding: 5px; background: #e8f5e9; border-radius: 3px;">
            âœ“ å‚æ•°è‡ªåŠ¨ä¼˜åŒ–å®Œæˆ (æµ‹è¯•äº† ${cfg.searchParams.combinationsTested} ä¸ªç»„åˆ)
        </div>` : '';
    
    const modeColor = cfg.mode === 'strict' ? '#4CAF50' : '#FF9800';
    const modeText = cfg.mode === 'strict' ? 
        'ä¸¥æ ¼æ¨¡å¼ (æ— çªå˜)' : 
        'è°ƒæ•´æ¨¡å¼ (å…è®¸ä¿®æ­£)';
    
    let searchInfo = '';
    if (cfg.mode === 'strict' && cfg.searchParams) {
        const attempts = cfg.searchParams.attempts || 1;
        const usedPerturb = attempts > 1;
        
        const attemptText = usedPerturb ? 
            `<span style="color: #FF9800;">æ‰°åŠ¨æœç´¢: ç¬¬ ${attempts} æ¬¡å°è¯•æˆåŠŸ</span>` : 
            '<span style="color: #4CAF50;">é¦–æ¬¡å°è¯•æˆåŠŸ (æ— éœ€æ‰°åŠ¨)</span>';
        
        searchInfo = `<p style="font-size: 12px; margin-top: 8px;">
            ${attemptText}
        </p>
        <p style="color: #666; font-size: 11px;">
            æ‰¾åˆ°å‚æ•°: hStart=${cfg.searchParams.hStart}Â°, 
            cBase=${cfg.searchParams.cBase}, lBase=${cfg.searchParams.lBase}
        </p>`;
        
        if (usedPerturb) {
            const cOriginal = cfg.chromaMax - cfg.chromaMin;
            const lOriginal = cfg.lumiMax - cfg.lumiMin;
            searchInfo += `<p style="color: #FF9800; font-size: 11px;">
                ç›®æ ‡èŒƒå›´: C=${cOriginal}, L=${lOriginal}
                <br>å®é™…èŒƒå›´: C=${cfg.searchParams.finalTargetC}, L=${cfg.searchParams.finalTargetL}
            </p>`;
        }
    }
    
    div.innerHTML = `
        <div class="colormap-title">Configuration</div>
        <div class="stats-box" style="background: #f0f8ff;">
            <p><strong>Mode:</strong> <span style="color: ${modeColor}; font-weight: bold;">${modeText}</span></p>
            ${autoSelectedNote}
            <p><strong>Hue Range:</strong> ${cfg.hueRange}Â°</p>
            <p><strong>Chroma:</strong> ${chromaDesc}</p>
            <p><strong>Luminance:</strong> ${lumiDesc}</p>
            ${searchInfo}
        </div>
    `;
    return div;
}

function createColormapBar() {
    const div = document.createElement('div');
    div.className = 'colormap-display';
    div.innerHTML = '<div class="colormap-title">Colormap Preview</div>';
    
    const canvas = document.createElement('canvas');
    canvas.width = currentColormap.length;
    canvas.height = 45;
    canvas.style.width = '600px';  // å›ºå®šå®½åº¦ï¼Œä¸è¦å¤ªé•¿
    canvas.style.height = '45px';
    canvas.style.marginLeft = '20px';
    canvas.style.imageRendering = 'pixelated';
    
    const ctx = canvas.getContext('2d');
    for (let i = 0; i < currentColormap.length; i++) {
        const color = currentColormap[i];
        ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
        ctx.fillRect(i, 0, 1, 45);
    }
    
    div.appendChild(canvas);
    return div;
}

function createHCLCurves() {
    const div = document.createElement('div');
    div.className = 'colormap-display';
    
    const hues = [], chromas = [], lumis = [];
    currentStats.hclData.forEach((hcl, i) => {
        hues.push([i, hcl[0]]);
        chromas.push([i, hcl[1]]);
        lumis.push([i, hcl[2]]);
    });
    
    // è®¡ç®—å®é™…çš„HueèŒƒå›´
    const hueValues = hues.map(d => d[1]);
    const hueStart = hueValues[0];
    const hueEnd = hueValues[hueValues.length - 1];
    const hueDiff = ((hueEnd - hueStart + 360) % 360).toFixed(1);
    
    div.innerHTML = `
        <div class="colormap-title">HCL Curves</div>
        <div style="margin-left: 20px; margin-bottom: 10px; color: #666; font-size: 12px;">
            Hue: ${hueStart.toFixed(1)}Â° â†’ ${hueEnd.toFixed(1)}Â°
        </div>
    `;
    
    const chartDiv = document.createElement('div');
    chartDiv.style.display = 'flex';
    chartDiv.style.gap = '10px';
    chartDiv.style.marginLeft = '20px';
    
    drawCurve([hues], chartDiv, 'Hue (ç»å¯¹å€¼)', 0, 360);
    drawCurve([chromas], chartDiv, 'Chroma', 0, 120);
    drawCurve([lumis], chartDiv, 'Luminance', 0, 100);
    
    div.appendChild(chartDiv);
    return div;
}

function drawCurve(data, container, name, yMin, yMax) {
    const width = 350, height = 200, margin = {top: 30, right: 20, bottom: 30, left: 40};
    
    const svg = d3.select(container).append('svg')
        .attr('width', width)
        .attr('height', height)
        .style('background', '#f9f9f9')
        .style('border-radius', '4px');
    
    const g = svg.append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
    
    const xScale = d3.scaleLinear()
        .domain([0, data[0].length - 1])
        .range([0, width - margin.left - margin.right]);
    
    const yScale = d3.scaleLinear()
        .domain([yMin, yMax])
        .range([height - margin.top - margin.bottom, 0]);
    
    const line = d3.line()
        .x(d => xScale(d[0]))
        .y(d => yScale(d[1]));
    
    g.selectAll('path')
        .data(data)
        .enter().append('path')
        .attr('d', line)
        .attr('fill', 'none')
        .attr('stroke', '#2196F3')
        .attr('stroke-width', 2);
    
    g.append('g')
        .attr('transform', `translate(0,${height - margin.top - margin.bottom})`)
        .call(d3.axisBottom(xScale).ticks(5));
    
    g.append('g')
        .call(d3.axisLeft(yScale).ticks(5));
    
    svg.append('text')
        .attr('x', width / 2)
        .attr('y', 20)
        .attr('text-anchor', 'middle')
        .style('font-size', '13px')
        .style('font-weight', 'bold')
        .text(name);
}

// é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
window.addEventListener('DOMContentLoaded', () => {
    // åˆå§‹åŒ– strict é€‰é¡¹æ˜¾ç¤º
    document.getElementById('strict-options').style.display = 'block';
    
    // å°è¯•åŠ è½½c3é¢œè‰²å‘½ååº“æ•°æ®
    try {
        console.log('Checking c3 library...');
        console.log('typeof c3:', typeof c3);
        
        if (typeof c3 !== 'undefined' && typeof c3.load === 'function') {
            console.log('Loading c3 data...');
            // Try loading with URL encoding for web compatibility
            const c3Path = '../rainbows good or bad for/supplementary materials/experiment interface/lib/colorname/c3_data.json';
            c3.load(c3Path, false);
            console.log('c3.load called with path:', c3Path);
            
            // Check if data was loaded
            if (c3.color && c3.terms) {
                console.log(`âœ“ c3 color naming library loaded successfully!`);
                console.log(`  - ${c3.color.length} colors`);
                console.log(`  - ${c3.terms.length} terms`);
                console.log(`  - Sample terms: ${c3.terms.slice(0, 5).join(', ')}`);
            } else {
                console.warn('âš  c3 loaded but data is incomplete');
                console.log('c3.color:', c3.color ? 'exists' : 'missing');
                console.log('c3.terms:', c3.terms ? 'exists' : 'missing');
            }
        } else {
            console.warn('âš  c3 library not found. Color naming metrics may not work.');
            console.log('typeof c3:', typeof c3);
            if (typeof c3 !== 'undefined') {
                console.log('c3.load:', typeof c3.load);
            }
        }
    } catch (error) {
        console.error('âŒ Failed to load c3 data:', error);
        console.warn('Color naming metrics will use fallback LAB distance.');
    }
});

function exportColormap() {
    if (!currentColormap) {
        alert('Please generate a colormap first!');
        return;
    }
    
    const rgbArray = currentColormap.map(c => [
        Math.round(c.r),
        Math.round(c.g),
        Math.round(c.b)
    ]);
    
    const exportData = {
        colormap: rgbArray,
        hcl: currentStats.hclData,
        config: currentStats.config,
        stats: {
            total: currentStats.total,
            adjusted: currentStats.invalid
        }
    };
    
    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `colormap_${Date.now()}.json`;
    link.click();
}

// ========== Static Metrics Functions ==========

// Helper function to get color name index from c3 library
function getColorNameIndex(c) {
    if (typeof c3 === 'undefined' || !c3.color) {
        console.warn('c3 library not loaded');
        return 0;
    }
    
    var x = d3.lab(c);
    var minDist = Number.MAX_VALUE;
    var minIndex = 0;
    
    // Get x LAB values with compatibility
    var xL = x.l !== undefined ? x.l : x.L;
    var xA = x.a;
    var xB = x.b;
    
    // Debug counter
    if (!getColorNameIndex.debugCount) {
        getColorNameIndex.debugCount = 0;
    }
    
    var debugThis = getColorNameIndex.debugCount < 2;
    if (debugThis) {
        console.log(`getColorNameIndex input: L=${xL}, a=${xA}, b=${xB}`);
    }
    
    for (var i = 0; i < c3.color.length; i++) {
        var c2 = c3.color[i];
        // c3.color uses uppercase L property (d3.lab objects)
        var c2L = c2.l !== undefined ? c2.l : c2.L;
        var c2A = c2.a;
        var c2B = c2.b;
        
        var dist = Math.sqrt(
            Math.pow(xL - c2L, 2) + 
            Math.pow(xA - c2A, 2) + 
            Math.pow(xB - c2B, 2)
        );
        
        if (debugThis && i < 5) {
            console.log(`  c3[${i}]: L=${c2L}, a=${c2A}, b=${c2B}, dist=${dist.toFixed(3)}`);
        }
        
        if (dist < minDist) {
            minDist = dist;
            minIndex = i;
        }
    }
    
    if (debugThis) {
        console.log(`  â†’ Best match: index=${minIndex}, dist=${minDist.toFixed(3)}, term=${c3.terms[minIndex]}`);
        getColorNameIndex.debugCount++;
    }
    
    return minIndex;
}

// Helper function to get name difference between two colors
function getNameDifference(c0, c1) {
    // Debug counter to limit log spam
    if (!getNameDifference.debugCount) {
        getNameDifference.debugCount = 0;
    }
    
    if (typeof c3 === 'undefined' || !c3.color) {
        if (getNameDifference.debugCount < 1) {
            console.warn('c3 library not loaded, using LAB distance instead');
            getNameDifference.debugCount++;
        }
        // Fallback to LAB distance
        var lab0 = d3.lab(c0);
        var lab1 = d3.lab(c1);
        var lVal0 = lab0.l !== undefined ? lab0.l : lab0.L;
        var lVal1 = lab1.l !== undefined ? lab1.l : lab1.L;
        return Math.sqrt(
            Math.pow(lVal1 - lVal0, 2) + 
            Math.pow(lab1.a - lab0.a, 2) + 
            Math.pow(lab1.b - lab0.b, 2)
        ) / 100; // Normalize to 0-1 range
    }
    
    var i0 = getColorNameIndex(c0);
    var i1 = getColorNameIndex(c1);
    
    if (getNameDifference.debugCount < 3) {
        console.log(`getNameDifference: i0=${i0}, i1=${i1}, c3.color.length=${c3.color ? c3.color.length : 'undefined'}`);
        if (c3.terms && i0 < c3.terms.length) {
            console.log(`  Color 0 name: ${c3.terms[i0]}`);
        }
        if (c3.terms && i1 < c3.terms.length) {
            console.log(`  Color 1 name: ${c3.terms[i1]}`);
        }
        getNameDifference.debugCount++;
    }
    
    if (i0 === i1) {
        if (getNameDifference.debugCount < 3) {
            console.log(`  Same index, returning 0`);
        }
        return 0;
    }
    
    // Use Hellinger distance between color name distributions
    try {
        var hellinger = c3.color.hellinger(i0, i1);
        if (getNameDifference.debugCount < 3) {
            console.log(`  Hellinger distance: ${hellinger}`);
        }
        return hellinger;
    } catch (e) {
        console.warn('Error calculating name difference:', e);
        return 0;
    }
}

// Helper function to get color name
function getColorName(c) {
    if (typeof c3 === 'undefined' || !c3.color || !c3.terms) {
        return ['unknown'];
    }
    
    try {
        var i = getColorNameIndex(c);
        var terms = c3.color.relatedTerms(i, 3);
        return terms.map(function(t) { return c3.terms[t.index]; });
    } catch (e) {
        console.warn('Error getting color name:', e);
        return ['unknown'];
    }
}

function nameSalience(c) {
    var minE = -4.5;
    var maxE = 0.0;
    var i = getColorNameIndex(c);
    var ent = c3.color.entropy(i);
    return (ent - minE) / (maxE - minE);
}

function hclDistance(c1, c2) {
    var d = Math.pow(c1.h - c2.h, 2) + Math.pow(c1.c - c2.c, 2) + Math.pow(c1.l - c2.l, 2);
    return Math.sqrt(d);
}

function termDistribution(c) {
    var i = getColorNameIndex(c);
    var terms = c3.terms;
    var dist = [];
    for (var w = 0; w < terms.length; w++) {
        dist.push({
            term: terms[w],
            p: c3.terms.prob(w, i)
        });
    }
    dist.sort(function(a, b) { return b.p - a.p; });
    return dist;
}

function findMeanStd(colors) {
    var meanJab = d3.jab(0, 0, 0);
    var mean = { l: 0, a: 0, b: 0 };
    var std = 0;

    for (var i=0; i<colors.length; i++) {
        var c = colors[i];
        mean.l += c.l;
        mean.a += c.a;
        mean.b += c.b;

        var cJab = d3.jab(c);
        meanJab.J += cJab.J;
        meanJab.a += cJab.a;
        meanJab.b += cJab.b;
    }

    if (colors.length > 0) {
        var k = 1/colors.length;
        mean.l *= k;
        mean.a *= k;
        mean.b *= k;

        meanJab.J *= k;
        meanJab.a *= k;
        meanJab.b *= k;
    }
    mean.L = mean.l;

    for (var i=0; i<colors.length; i++) {
        var c = colors[i];
        var d = Math.pow(c.l - mean.l, 2) + Math.pow(c.a - mean.a, 2) + Math.pow(c.b - mean.b, 2);
        std += d;
    }
    if (colors.length > 0) {
        std *= 1/colors.length;
    }
    return {
        mean: d3.hcl(mean.l, mean.c, mean.h), 
        std: Math.sqrt(std)
    };
}

function localNameDistances(colors) {
    var nameDistances = [];
    for (var i = 0; i < colors.length - 1; i++) {
        var c0 = colors[i];
        var c1 = colors[i + 1];
        var d = getNameDifference(c0, c1);
        nameDistances.push(d);
    }
    return nameDistances;
}

function createStandardizedColormap(colormap) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return null;
    }

    let [minValue, maxValue] = [0, 1];
    try {
        const range = colormap.getMinMax ? colormap.getMinMax() : null;
        if (range && range.length === 2) {
            [minValue, maxValue] = range;
        }
    } catch (error) {
        console.warn("Cannot get colormap range, using default [0, 1]:", error);
    }

    const SAMPLE_SIZE = 256;
    const standardizedColors = [];

    for (let i = 0; i < SAMPLE_SIZE; i++) {
        const t = minValue + (i / (SAMPLE_SIZE - 1)) * (maxValue - minValue);
        
        try {
            const color = colormap.mapValue ? colormap.mapValue(t) : null;
            
            if (color) {
                let r, g, b;
                
                if (typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number') {
                    r = color.r;
                    g = color.g;
                    b = color.b;
                } else if (color.rgb && typeof color.rgb.r === 'number') {
                    r = color.rgb.r;
                    g = color.rgb.g;
                    b = color.rgb.b;
                } else if (typeof color.toString === 'function') {
                    const rgbString = color.toString();
                    const rgbMatch = rgbString.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
                    if (rgbMatch) {
                        r = parseInt(rgbMatch[1], 10);
                        g = parseInt(rgbMatch[2], 10);
                        b = parseInt(rgbMatch[3], 10);
                    }
                }
                
                if (typeof r === 'number' && typeof g === 'number' && typeof b === 'number') {
                    standardizedColors.push({
                        value: (t - minValue) / (maxValue - minValue),
                        rgb: [r, g, b]
                    });
                }
            }
        } catch (error) {
            console.error(`Error getting color at position ${t}:`, error);
        }
    }

    if (standardizedColors.length === 0) {
        console.error("No valid colors found in colormap");
        return null;
    }

    return standardizedColors;
}

function computeDeltaE(L1, a1, b1, L2, a2, b2, wa = 0.1, wb = 0.1) {
    if (isNaN(L1) || isNaN(a1) || isNaN(b1) || isNaN(L2) || isNaN(a2) || isNaN(b2)) {
        console.error("computeDeltaE received invalid parameters:", { L1, a1, b1, L2, a2, b2 });
        return 0;
    }
    
    let deltaL = L1 - L2;
    let deltaA = a1 - a2;
    let deltaB = b1 - b2;
    
    if (isNaN(deltaL) || isNaN(deltaA) || isNaN(deltaB)) {
        console.error("computeDeltaE calculation error:", { deltaL, deltaA, deltaB });
        return 0;
    }
    
    const result = Math.sqrt(
        Math.pow(deltaL, 2) + 
        wa * Math.pow(deltaA, 2) + 
        wb * Math.pow(deltaB, 2)
    );
    
    if (isNaN(result)) {
        console.error("computeDeltaE final result is NaN");
        return 0;
    }
    
    return result;
}

function discriminatory_cie(colormap) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return 0;
    }
    
    const colors = createStandardizedColormap(colormap);
    
    if (!colors || !colors.length) {
        console.error("Invalid colors array:", colors);
        return 0;
    }
    
    let totalSpeed = 0;
    let pairCount = 0;
    
    for (let i = 0; i < colors.length; i++) {
        for (let j = i + 1; j < colors.length; j++) {
            const rgbColor1 = d3.rgb(colors[i].rgb[0], colors[i].rgb[1], colors[i].rgb[2]);
            const rgbColor2 = d3.rgb(colors[j].rgb[0], colors[j].rgb[1], colors[j].rgb[2]);
            const lab1 = d3.lab(rgbColor1);
            const lab2 = d3.lab(rgbColor2);
            
            // Use our existing ciede2000 function
            // d3 v7 uses uppercase L, lowercase a, b
            const deltaE = ciede2000([lab1.l || lab1.L, lab1.a, lab1.b], [lab2.l || lab2.L, lab2.a, lab2.b]);
            const v_ij = deltaE / Math.abs((j - i) / (colors.length - 1));
            totalSpeed += v_ij;
            pairCount++;
        }
    }
    
    const globalDiscriminativePower = pairCount > 0 ? totalSpeed / pairCount : 0;
    return globalDiscriminativePower;
}

function discriminatory_contrast_sensitivity(colormap) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return 0;
    }
    
    const colors = createStandardizedColormap(colormap);

    if (!colors || !colors.length) {
        console.error("Invalid colors array:", colors);
        return 0;
    }
    
    let totalSpeed = 0;
    let pairCount = 0;
    
    try {
        for (let i = 0; i < colors.length; i++) {
            for (let j = i + 1; j < colors.length; j++) {
                try {
                    const rgbColor1 = d3.rgb(colors[i].rgb[0], colors[i].rgb[1], colors[i].rgb[2]);
                    const rgbColor2 = d3.rgb(colors[j].rgb[0], colors[j].rgb[1], colors[j].rgb[2]);
                    
                    if (!rgbColor1 || !rgbColor2) {
                        continue;
                    }
                    
                    const lab1 = d3.lab(rgbColor1);
                    const lab2 = d3.lab(rgbColor2);
                    
                    // d3 v7 uses lowercase l, but some versions use uppercase L
                    const l1 = Number(lab1.l !== undefined ? lab1.l : lab1.L);
                    const a1 = Number(lab1.a);
                    const b1 = Number(lab1.b);
                    const l2 = Number(lab2.l !== undefined ? lab2.l : lab2.L);
                    const a2 = Number(lab2.a);
                    const b2 = Number(lab2.b);
                    
                    const deltaE = computeDeltaE(l1, a1, b1, l2, a2, b2);
                    
                    if (isNaN(deltaE)) {
                        console.warn(`deltaE is NaN for pair [${i}, ${j}]`);
                        continue;
                    }
                    
                    if (deltaE === 0) {
                        continue; // Skip identical colors
                    }
                    
                    const normalizationFactor = Math.abs((j - i) / (colors.length - 1));
                    
                    if (normalizationFactor === 0) {
                        console.warn(`normalizationFactor is 0 for pair [${i}, ${j}]`);
                        continue;
                    }
                    
                    const v_ij = deltaE / normalizationFactor;
                    
                    if (isNaN(v_ij)) {
                        console.warn(`v_ij is NaN for pair [${i}, ${j}]`);
                        continue;
                    }
                    
                    const contribution = 3.4 * Math.pow(v_ij, 0.879);
                    
                    totalSpeed += contribution;
                    pairCount++;
                    
                } catch (error) {
                    console.error(`Error processing color pair [${i}, ${j}]:`, error);
                }
            }
        }
        
        const globalDiscriminativePower = pairCount > 0 ? totalSpeed / pairCount : 0;
        return globalDiscriminativePower;
    } catch (error) {
        console.error("discriminatory_contrast_sensitivity error:", error);
        return 0;
    }
}

function discriminatory_hue(colormap) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return 0;
    }

    const colors = createStandardizedColormap(colormap);

    if (!colors || !colors.length) {
        console.error("Invalid colors array:", colors);
        return 0;
    }

    let totalSpeed = 0;
    let pairCount = 0;

    for (let i = 0; i < colors.length; i++) {
        for (let j = i + 1; j < colors.length; j++) {
            const rgbColor1 = d3.rgb(colors[i].rgb[0], colors[i].rgb[1], colors[i].rgb[2]);
            const rgbColor2 = d3.rgb(colors[j].rgb[0], colors[j].rgb[1], colors[j].rgb[2]);
            
            const hcl1 = d3.hcl(rgbColor1);
            const hcl2 = d3.hcl(rgbColor2);
            
            // d3.hcl may return h as NaN for achromatic colors
            const h1 = isNaN(hcl1.h) ? 0 : hcl1.h;
            const h2 = isNaN(hcl2.h) ? 0 : hcl2.h;
            
            let hueDiff = Math.abs(h1 - h2);
            if (hueDiff > 180) {
                hueDiff = 360 - hueDiff;
            }
            
            const normalizedHueDiff = hueDiff;
            const normFactor = Math.abs((j - i) / (colors.length - 1));
            const v_ij = normalizedHueDiff / normFactor;
            
            if (isNaN(v_ij)) {
                console.warn(`Hue v_ij is NaN for pair [${i}, ${j}]`);
            }
            
            totalSpeed += v_ij;
            pairCount++;
        }
    }

    const globalDiscriminativePower = pairCount > 0 ? totalSpeed / pairCount : 0;
    return globalDiscriminativePower;
}

function luminance_variation(colormap) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return 0;
    }

    const colors = createStandardizedColormap(colormap);

    if (!colors || !colors.length) {
        console.error("Invalid colors array:", colors);
        return 0;
    }

    const luminanceValues = [];
    for (let i = 0; i < colors.length; i++) {
        try {
            const r = parseInt(colors[i].rgb[0]);
            const g = parseInt(colors[i].rgb[1]);
            const b = parseInt(colors[i].rgb[2]);

            if (isNaN(r) || isNaN(g) || isNaN(b)) {
                console.error(`Invalid rgb values for color ${i}:`, colors[i].rgb);
                continue;
            }

            const rgbColor = d3.rgb(r, g, b);
            const hcl = d3.hcl(rgbColor);
            
            // Handle both lowercase l and uppercase L
            const lValue = hcl.l !== undefined ? hcl.l : hcl.L;
            if (hcl && typeof lValue === 'number' && !isNaN(lValue)) {
                luminanceValues.push(lValue);
            } else {
                console.error(`Invalid luminance for color ${i}:`, hcl);
            }
        } catch (error) {
            console.error(`Error processing color ${i}:`, error);
        }
    }

    if (luminanceValues.length === 0) {
        console.error("No valid luminance values calculated");
        return null;
    }

    let totalVariation = 0;
    for (let i = 1; i < luminanceValues.length; i++) {
        totalVariation += Math.abs(luminanceValues[i] - luminanceValues[i-1]);
    }

    return totalVariation;
}

function chromatic_variation(colormap) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return 0;
    }

    const colors = createStandardizedColormap(colormap);

    if (!colors || !colors.length) {
        console.error("Invalid colors array:", colors);
        return 0;
    }

    const saturationValues = [];
    for (let i = 0; i < colors.length; i++) {
        try {
            const r = parseInt(colors[i].rgb[0]);
            const g = parseInt(colors[i].rgb[1]);
            const b = parseInt(colors[i].rgb[2]);

            if (isNaN(r) || isNaN(g) || isNaN(b)) {
                console.error(`Invalid rgb values for color ${i}:`, colors[i].rgb);
                continue;
            }

            const rgbColor = d3.rgb(r, g, b);
            const hcl = d3.hcl(rgbColor);
            
            // Handle both lowercase c and uppercase C
            const cValue = hcl.c !== undefined ? hcl.c : hcl.C;
            if (hcl && typeof cValue === 'number' && !isNaN(cValue)) {
                saturationValues.push(cValue);
            } else {
                console.error(`Invalid saturation for color ${i}:`, hcl);
            }
        } catch (error) {
            console.error(`Error processing color ${i}:`, error);
        }
    }

    if (saturationValues.length === 0) {
        console.error("No valid saturation values calculated");
        return null;
    }

    let totalVariation = 0;
    for (let i = 1; i < saturationValues.length; i++) {
        totalVariation += Math.abs(saturationValues[i] - saturationValues[i-1]);
    }

    return totalVariation;
}

function calculate_lab_length(colormap, sampleCount = 9) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return 0;
    }

    const colors = createStandardizedColormap(colormap);

    if (!colors || !colors.length) {
        console.error("Invalid colors array:", colors);
        return 0;
    }

    const samples = [];
    const step = (colors.length - 1) / (sampleCount - 1);
    
    for (let i = 0; i < sampleCount; i++) {
        const index = Math.min(Math.floor(i * step), colors.length - 1);
        try {
            const r = parseInt(colors[index].rgb[0]);
            const g = parseInt(colors[index].rgb[1]);
            const b = parseInt(colors[index].rgb[2]);

            if (isNaN(r) || isNaN(g) || isNaN(b)) {
                console.error(`Invalid rgb values for sampled color ${i}:`, colors[index].rgb);
                continue;
            }

            const rgbColor = d3.rgb(r, g, b);
            const lab = d3.lab(rgbColor);
            
            // Ensure all LAB values are valid numbers
            const lValue = lab.l !== undefined ? lab.l : lab.L;
            if (!isNaN(lValue) && !isNaN(lab.a) && !isNaN(lab.b)) {
                samples.push(lab);
            }
        } catch (error) {
            console.error(`Error sampling color ${i}:`, error);
        }
    }

    if (samples.length < 2) {
        console.error("Not enough valid samples for LAB length calculation");
        return 0;
    }

    let totalLabLength = 0;
    
    for (let i = 0; i < samples.length - 1; i++) {
        const lab1 = samples[i];
        const lab2 = samples[i + 1];
        
        // Handle both lowercase l and uppercase L
        const l1 = lab1.l !== undefined ? lab1.l : lab1.L;
        const l2 = lab2.l !== undefined ? lab2.l : lab2.L;
        
        const distance = Math.sqrt(
            Math.pow(l2 - l1, 2) + 
            Math.pow(lab2.a - lab1.a, 2) + 
            Math.pow(lab2.b - lab1.b, 2)
        );
        
        if (isNaN(distance)) {
            console.warn(`LAB distance is NaN for samples ${i}-${i+1}`);
        }
        
        totalLabLength += distance;
    }
    
    return totalLabLength;
}

function calculate_color_name_variation(colormap, sampleCount = 9) {
    if (!colormap) {
        console.error("Invalid colormap object:", colormap);
        return 0;
    }

    const colors = createStandardizedColormap(colormap);

    if (!colors || !colors.length) {
        console.error("Invalid colors array:", colors);
        return 0;
    }

    const samples = [];
    const step = (colors.length - 1) / (sampleCount - 1);
    
    for (let i = 0; i < sampleCount; i++) {
        const index = Math.min(Math.floor(i * step), colors.length - 1);
        try {
            const r = parseInt(colors[index].rgb[0]);
            const g = parseInt(colors[index].rgb[1]);
            const b = parseInt(colors[index].rgb[2]);

            if (isNaN(r) || isNaN(g) || isNaN(b)) {
                console.error(`Invalid rgb values for sampled color ${i}:`, colors[index].rgb);
                continue;
            }

            samples.push(d3.rgb(r, g, b));
        } catch (error) {
            console.error(`Error sampling color ${i}:`, error);
        }
    }

    let totalNameDifference = 0;
    let validPairs = 0;
    
    for (let i = 0; i < samples.length - 1; i++) {
        try {
            const c0 = samples[i];
            const c1 = samples[i + 1];
            if (c0 && c1 && typeof getNameDifference === 'function') {
                const nameDiff = getNameDifference(c0, c1);
                
                if (!isNaN(nameDiff) && isFinite(nameDiff)) {
                    totalNameDifference += nameDiff;
                    validPairs++;
                }
            }
        } catch (error) {
            console.error(`Error calculating name difference for samples ${i} and ${i+1}:`, error);
        }
    }

    if (validPairs === 0) {
        console.warn("No valid name difference pairs calculated");
        return 0;
    }
    
    return totalNameDifference;
}

// Create Static Metrics display box
function createStaticMetricsBox() {
    const div = document.createElement('div');
    div.className = 'colormap-display';
    div.innerHTML = '<div class="colormap-title">Static Metrics</div><div id="metrics-content" style="padding: 10px;"><p style="color: #999; text-align: center;">Calculating metrics...</p></div>';
    
    // Calculate metrics asynchronously to avoid blocking UI
    setTimeout(() => {
        try {
            const colormapObj = convertToColorMapObject();
            
            if (!colormapObj) {
                document.getElementById('metrics-content').innerHTML = '<p style="color: #f44336;">Unable to calculate metrics (ColorMap conversion failed)</p>';
                return;
            }
            
            console.log('Calculating static metrics...');
            
            // Calculate all metrics with error handling
            let metrics = {};
            
            try {
                metrics.discriminatory_cie = discriminatory_cie(colormapObj);
                console.log('CIEDE2000 Discriminative Power:', metrics.discriminatory_cie);
            } catch (e) {
                console.error('Error calculating CIEDE2000:', e);
                metrics.discriminatory_cie = 'N/A';
            }
            
            try {
                metrics.discriminatory_contrast = discriminatory_contrast_sensitivity(colormapObj);
                console.log('Contrast Sensitivity:', metrics.discriminatory_contrast);
            } catch (e) {
                console.error('Error calculating Contrast Sensitivity:', e);
                metrics.discriminatory_contrast = 'N/A';
            }
            
            try {
                metrics.discriminatory_hue = discriminatory_hue(colormapObj);
                console.log('Hue Discriminative Power:', metrics.discriminatory_hue);
            } catch (e) {
                console.error('Error calculating Hue Discriminative Power:', e);
                metrics.discriminatory_hue = 'N/A';
            }
            
            try {
                metrics.luminance_var = luminance_variation(colormapObj);
                console.log('Luminance Variation:', metrics.luminance_var);
            } catch (e) {
                console.error('Error calculating Luminance Variation:', e);
                metrics.luminance_var = 'N/A';
            }
            
            try {
                metrics.chromatic_var = chromatic_variation(colormapObj);
                console.log('Chromatic Variation:', metrics.chromatic_var);
            } catch (e) {
                console.error('Error calculating Chromatic Variation:', e);
                metrics.chromatic_var = 'N/A';
            }
            
            try {
                metrics.lab_length = calculate_lab_length(colormapObj);
                console.log('LAB Length:', metrics.lab_length);
            } catch (e) {
                console.error('Error calculating LAB Length:', e);
                metrics.lab_length = 'N/A';
            }
            
            try {
                // Color name variation may not work if c3 library is not loaded
                if (typeof getNameDifference === 'function') {
                    metrics.color_name_var = calculate_color_name_variation(colormapObj);
                    console.log('Color Name Variation:', metrics.color_name_var);
                } else {
                    metrics.color_name_var = 'N/A (c3 not loaded)';
                }
            } catch (e) {
                console.error('Error calculating Color Name Variation:', e);
                metrics.color_name_var = 'N/A';
            }
            
            // Format the values
            const formatValue = (val) => {
                if (val === 'N/A' || typeof val === 'string') return val;
                if (val === null || val === undefined) return 'N/A';
                return typeof val === 'number' ? val.toFixed(3) : 'N/A';
            };
            
            // Display metrics in a table
            let html = '<div class="stats-box" style="background: #f0f8ff;">';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="background: #e3f2fd;"><th style="text-align: left; padding: 8px; border: 1px solid #ddd;">Metric</th><th style="text-align: right; padding: 8px; border: 1px solid #ddd;">Value</th></tr>';
            
            html += `<tr><td style="padding: 6px; border: 1px solid #ddd;"><strong>CIEDE2000 Discriminative Power</strong></td><td style="text-align: right; padding: 6px; border: 1px solid #ddd;">${formatValue(metrics.discriminatory_cie)}</td></tr>`;
            html += `<tr style="background: #f9f9f9;"><td style="padding: 6px; border: 1px solid #ddd;"><strong>Contrast Sensitivity</strong></td><td style="text-align: right; padding: 6px; border: 1px solid #ddd;">${formatValue(metrics.discriminatory_contrast)}</td></tr>`;
            html += `<tr><td style="padding: 6px; border: 1px solid #ddd;"><strong>Hue Discriminative Power</strong></td><td style="text-align: right; padding: 6px; border: 1px solid #ddd;">${formatValue(metrics.discriminatory_hue)}</td></tr>`;
            html += `<tr style="background: #f9f9f9;"><td style="padding: 6px; border: 1px solid #ddd;"><strong>Luminance Variation</strong></td><td style="text-align: right; padding: 6px; border: 1px solid #ddd;">${formatValue(metrics.luminance_var)}</td></tr>`;
            html += `<tr><td style="padding: 6px; border: 1px solid #ddd;"><strong>Chromatic Variation</strong></td><td style="text-align: right; padding: 6px; border: 1px solid #ddd;">${formatValue(metrics.chromatic_var)}</td></tr>`;
            html += `<tr style="background: #f9f9f9;"><td style="padding: 6px; border: 1px solid #ddd;"><strong>LAB Length</strong></td><td style="text-align: right; padding: 6px; border: 1px solid #ddd;">${formatValue(metrics.lab_length)}</td></tr>`;
            html += `<tr><td style="padding: 6px; border: 1px solid #ddd;"><strong>Color Name Variation</strong></td><td style="text-align: right; padding: 6px; border: 1px solid #ddd;">${formatValue(metrics.color_name_var)}</td></tr>`;
            
            html += '</table>';
            html += '</div>';
            
            html += '<div style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 4px; font-size: 11px; color: #856404;">';
            html += '<strong>Note:</strong> Some metrics may show "N/A" if required libraries (e.g., c3 color naming) are not properly loaded.';
            html += '</div>';
            
            document.getElementById('metrics-content').innerHTML = html;
            
        } catch (error) {
            console.error('Error calculating static metrics:', error);
            document.getElementById('metrics-content').innerHTML = `<p style="color: #f44336;">Error calculating metrics: ${error.message}</p>`;
        }
    }, 100);
    
    return div;
}

// Helper function to convert current colormap to ColorMap object
function convertToColorMapObject() {
    if (!currentColormap || currentColormap.length === 0) {
        return null;
    }
    
    const colorset = [];
    for (let i = 0; i < currentColormap.length; i++) {
        const rgb = currentColormap[i];
        colorset.push({
            value: i / (currentColormap.length - 1),
            rgb: [rgb.r, rgb.g, rgb.b]
        });
    }
    
    try {
        if (typeof ColorMap === 'undefined') {
            console.error('ColorMap class is not defined');
            return null;
        }
        return new ColorMap(colorset, 'rgb');
    } catch (error) {
        console.error("Error creating ColorMap object:", error);
        return null;
    }
}

</script>

</body>
</html>
