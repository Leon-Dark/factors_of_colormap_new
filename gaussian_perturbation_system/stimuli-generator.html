<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <title>Colormap Generation</title>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="../rainbows good or bad for/supplementary materials/experiment interface/lib/colorname/c3.js"></script>
</head>

<body>
    <div style="padding: 20px; background: #f5f5f5; border-bottom: 2px solid #4CAF50;">
        <h1 style="margin: 0 0 10px 0; color: #333;">Colormap Generator with Quality Metrics</h1>
        <button onclick="generateAll()" style="padding: 10px 20px; font-size: 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
            🎨 Generate All Colormaps
        </button>
        <p style="color: #666; margin: 10px 0 0 0; font-size: 14px;">Click the button to generate colormaps with quality metrics. Open Console (F12) to see detailed logs.</p>
        
        <!-- Statistics Panel -->
        <div id="statisticsPanel" style="display: none; margin-top: 15px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <h3 style="margin: 0 0 10px 0; color: #333; font-size: 16px;">📊 Statistics</h3>
            <div style="border-bottom: 2px solid #e0e0e0; margin-bottom: 10px;"></div>
            
            <!-- Overall Statistics -->
            <div id="overallStats" style="font-size: 14px; margin-bottom: 15px; display: flex; gap: 20px; flex-wrap: wrap;">
                <div><strong>Total generated:</strong> <span id="totalCount">0</span></div>
                <div style="color: #4CAF50;"><strong>✅ Pass both conditions:</strong> <span id="passCount">0</span> (<span id="passPercent">0</span>%)</div>
                <div style="color: #FF9800;"><strong>⚠️ Fail Condition 1 only:</strong> <span id="failCond1Count">0</span> (<span id="failCond1Percent">0</span>%)</div>
                <div style="color: #9C27B0;"><strong>⚠️ Fail Condition 2 only:</strong> <span id="failCond2Count">0</span> (<span id="failCond2Percent">0</span>%)</div>
                <div style="color: #f44336;"><strong>❌ Fail both conditions:</strong> <span id="failBothCount">0</span> (<span id="failBothPercent">0</span>%)</div>
            </div>
            
            <!-- Detailed Statistics (Collapsible) -->
            <details style="margin-top: 10px;">
                <summary style="cursor: pointer; font-weight: bold; color: #666; padding: 5px 0;">Detailed breakdown ▼</summary>
                <div id="detailedStats" style="margin-top: 10px; padding: 10px; background: #f9f9f9; border-radius: 4px; font-size: 13px;">
                    <!-- Will be populated by JavaScript -->
                </div>
            </details>
            
            <!-- Threshold Adjustment Panel -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                <div style="font-weight: bold; margin-bottom: 12px; color: #555;">🎚️ Filter conditions:</div>
                
                <!-- Condition 1: Min Color Diff -->
                <div style="margin-bottom: 15px; padding: 10px; background: #f9f9f9; border-radius: 4px;">
                    <div style="font-weight: 500; margin-bottom: 8px; color: #666;">📏 Condition 1: Min Color Diff (JND-based)</div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="thresholdSlider" style="min-width: 100px; font-size: 13px;">Threshold ≥</label>
                        <input type="range" id="thresholdSlider" min="0" max="10" step="0.1" value="3" 
                               style="flex: 1; cursor: pointer;" oninput="updateThreshold(this.value)">
                        <input type="number" id="thresholdValue" min="0" max="10" step="0.1" value="3" 
                               style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px;"
                               oninput="updateThreshold(this.value)">
                    </div>
                </div>
                
                <!-- Condition 2: Sample Interval Check -->
                <div style="padding: 10px; background: #f0f8ff; border-radius: 4px;">
                    <div style="font-weight: 500; margin-bottom: 8px; color: #666;">📐 Condition 2: Sample Interval Color Diff</div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <label for="intervalKSlider" style="min-width: 100px; font-size: 13px;">Interval k =</label>
                        <input type="range" id="intervalKSlider" min="1" max="20" step="1" value="5" 
                               style="flex: 1; cursor: pointer;" oninput="updateIntervalParams(this.value, document.getElementById('intervalJValue').value)">
                        <input type="number" id="intervalKValue" min="1" max="20" step="1" value="5" 
                               style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px;"
                               oninput="updateIntervalParams(this.value, document.getElementById('intervalJValue').value)">
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <label for="intervalJSlider" style="min-width: 100px; font-size: 13px;">Min Diff j ≥</label>
                        <input type="range" id="intervalJSlider" min="0" max="50" step="0.5" value="10" 
                               style="flex: 1; cursor: pointer;" oninput="updateIntervalParams(document.getElementById('intervalKValue').value, this.value)">
                        <input type="number" id="intervalJValue" min="0" max="50" step="0.5" value="10" 
                               style="width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px;"
                               oninput="updateIntervalParams(document.getElementById('intervalKValue').value, this.value)">
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 6px; font-style: italic;">
                        Check: Color diff between sample[i] and sample[i+k] ≥ j
                    </div>
                </div>
            </div>
            
            <!-- Filter Controls -->
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #555;">Display mode:</div>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <label style="cursor: pointer;">
                        <input type="radio" name="filterMode" value="all" checked onchange="applyFilter()"> 
                        Show all (<span id="filterAllCount">0</span>)
                    </label>
                    <label style="cursor: pointer; color: #4CAF50;">
                        <input type="radio" name="filterMode" value="pass" onchange="applyFilter()"> 
                        Pass both (<span id="filterPassCount">0</span>)
                    </label>
                    <label style="cursor: pointer; color: #FF9800;">
                        <input type="radio" name="filterMode" value="failCond1" onchange="applyFilter()"> 
                        Fail Cond 1 only (<span id="filterFailCond1Count">0</span>)
                    </label>
                    <label style="cursor: pointer; color: #9C27B0;">
                        <input type="radio" name="filterMode" value="failCond2" onchange="applyFilter()"> 
                        Fail Cond 2 only (<span id="filterFailCond2Count">0</span>)
                    </label>
                    <label style="cursor: pointer; color: #f44336;">
                        <input type="radio" name="filterMode" value="failBoth" onchange="applyFilter()"> 
                        Fail both (<span id="filterFailBothCount">0</span>)
                    </label>
                    <label style="cursor: pointer; color: #999;">
                        <input type="radio" name="filterMode" value="failAny" onchange="applyFilter()"> 
                        Fail any (<span id="filterFailAnyCount">0</span>)
                    </label>
                </div>
            </div>
        </div>
    </div>
</body>

<!-- <script type="text/javascript" src="/static/js/metrics.js"></script> -->
<script>
    // Global variables for statistics and filtering
    let allColormaps = [];
    let colormapElements = [];
    let MIN_COLOR_DIFF_THRESHOLD = 3;
    let SAMPLE_INTERVAL_K = 5;
    let MIN_INTERVAL_DIFF_J = 10;

    // Helper function to get category labels
    function getCategoryLabels(chroma, lumi) {
        let chromaLabel = '';
        let lumiLabel = '';
        
        if (chroma.length === 2 && chroma[0] === chroma[1]) {
            chromaLabel = 'Constant';
        } else if (chroma.length === 2) {
            chromaLabel = 'Linear';
        } else if (chroma.length === 3) {
            chromaLabel = 'Diverging';
        } else if (chroma.length === 5) {
            chromaLabel = 'Thermal';
        }
        
        if (lumi.length === 2 && lumi[0] === lumi[1]) {
            lumiLabel = 'Constant';
        } else if (lumi.length === 2) {
            lumiLabel = 'Linear';
        } else if (lumi.length === 3) {
            lumiLabel = 'Diverging';
        } else if (lumi.length === 5) {
            lumiLabel = 'Thermal';
        }
        
        return { chromaLabel, lumiLabel };
    }

    // Calculate and update statistics
    function updateStatistics() {
        const total = allColormaps.length;
        
        // Categorize colormaps by which conditions they pass/fail
        let passBoth = 0, failCond1Only = 0, failCond2Only = 0, failBoth = 0;
        
        allColormaps.forEach(cm => {
            const passCond1 = cm.metrics.smoothness_min_diff >= MIN_COLOR_DIFF_THRESHOLD;
            const passCond2 = cm.metrics.sample_interval_min_diff >= MIN_INTERVAL_DIFF_J;
            
            if (passCond1 && passCond2) {
                passBoth++;
            } else if (!passCond1 && passCond2) {
                failCond1Only++;
            } else if (passCond1 && !passCond2) {
                failCond2Only++;
            } else {
                failBoth++;
            }
        });
        
        const failAny = failCond1Only + failCond2Only + failBoth;

        document.getElementById('totalCount').textContent = total;
        document.getElementById('passCount').textContent = passBoth;
        document.getElementById('passPercent').textContent = total > 0 ? ((passBoth / total) * 100).toFixed(1) : 0;
        
        document.getElementById('failCond1Count').textContent = failCond1Only;
        document.getElementById('failCond1Percent').textContent = total > 0 ? ((failCond1Only / total) * 100).toFixed(1) : 0;
        
        document.getElementById('failCond2Count').textContent = failCond2Only;
        document.getElementById('failCond2Percent').textContent = total > 0 ? ((failCond2Only / total) * 100).toFixed(1) : 0;
        
        document.getElementById('failBothCount').textContent = failBoth;
        document.getElementById('failBothPercent').textContent = total > 0 ? ((failBoth / total) * 100).toFixed(1) : 0;
        
        document.getElementById('filterAllCount').textContent = total;
        document.getElementById('filterPassCount').textContent = passBoth;
        document.getElementById('filterFailCond1Count').textContent = failCond1Only;
        document.getElementById('filterFailCond2Count').textContent = failCond2Only;
        document.getElementById('filterFailBothCount').textContent = failBoth;
        document.getElementById('filterFailAnyCount').textContent = failAny;

        // Calculate detailed statistics
        updateDetailedStatistics();

        // Show statistics panel
        document.getElementById('statisticsPanel').style.display = 'block';
    }

    // Calculate detailed breakdown statistics
    function updateDetailedStatistics() {
        const stats = {
            byHue: {},
            byChroma: {},
            byLumi: {}
        };

        allColormaps.forEach(cm => {
            const isPassingCond1 = cm.metrics.smoothness_min_diff >= MIN_COLOR_DIFF_THRESHOLD;
            const isPassingCond2 = cm.metrics.sample_interval_min_diff >= MIN_INTERVAL_DIFF_J;
            
            // By Hue
            const hueKey = cm.hueCount === 3 ? '3 Hues' : cm.hueCount === 2 ? '5 Hues' : '7 Hues';
            if (!stats.byHue[hueKey]) stats.byHue[hueKey] = { total: 0, passBoth: 0, failCond1Only: 0, failCond2Only: 0, failBoth: 0 };
            stats.byHue[hueKey].total++;
            if (isPassingCond1 && isPassingCond2) stats.byHue[hueKey].passBoth++;
            else if (!isPassingCond1 && isPassingCond2) stats.byHue[hueKey].failCond1Only++;
            else if (isPassingCond1 && !isPassingCond2) stats.byHue[hueKey].failCond2Only++;
            else stats.byHue[hueKey].failBoth++;

            // By Chroma
            const chromaKey = cm.chromaLabel;
            if (!stats.byChroma[chromaKey]) stats.byChroma[chromaKey] = { total: 0, passBoth: 0, failCond1Only: 0, failCond2Only: 0, failBoth: 0 };
            stats.byChroma[chromaKey].total++;
            if (isPassingCond1 && isPassingCond2) stats.byChroma[chromaKey].passBoth++;
            else if (!isPassingCond1 && isPassingCond2) stats.byChroma[chromaKey].failCond1Only++;
            else if (isPassingCond1 && !isPassingCond2) stats.byChroma[chromaKey].failCond2Only++;
            else stats.byChroma[chromaKey].failBoth++;

            // By Lumi
            const lumiKey = cm.lumiLabel;
            if (!stats.byLumi[lumiKey]) stats.byLumi[lumiKey] = { total: 0, passBoth: 0, failCond1Only: 0, failCond2Only: 0, failBoth: 0 };
            stats.byLumi[lumiKey].total++;
            if (isPassingCond1 && isPassingCond2) stats.byLumi[lumiKey].passBoth++;
            else if (!isPassingCond1 && isPassingCond2) stats.byLumi[lumiKey].failCond1Only++;
            else if (isPassingCond1 && !isPassingCond2) stats.byLumi[lumiKey].failCond2Only++;
            else stats.byLumi[lumiKey].failBoth++;
        });

        // Render detailed statistics
        let html = '';
        
        html += '<div style="margin-bottom: 15px;"><strong>By hue count:</strong><table style="width: 100%; margin-top: 5px; border-collapse: collapse;">';
        html += '<tr style="background: #e0e0e0; font-weight: bold;"><td style="padding: 4px; border: 1px solid #ccc;">Hue count</td><td style="padding: 4px; border: 1px solid #ccc;">Total</td><td style="padding: 4px; border: 1px solid #ccc; color: #4CAF50;">Pass both</td><td style="padding: 4px; border: 1px solid #ccc; color: #FF9800;">Fail Cond 1 only</td><td style="padding: 4px; border: 1px solid #ccc; color: #9C27B0;">Fail Cond 2 only</td><td style="padding: 4px; border: 1px solid #ccc; color: #f44336;">Fail both</td></tr>';
        Object.entries(stats.byHue).forEach(([key, val]) => {
            html += `<tr><td style="padding: 4px; border: 1px solid #ccc;">${key}</td><td style="padding: 4px; border: 1px solid #ccc;">${val.total}</td><td style="padding: 4px; border: 1px solid #ccc; color: #4CAF50;">${val.passBoth}</td><td style="padding: 4px; border: 1px solid #ccc; color: #FF9800;">${val.failCond1Only}</td><td style="padding: 4px; border: 1px solid #ccc; color: #9C27B0;">${val.failCond2Only}</td><td style="padding: 4px; border: 1px solid #ccc; color: #f44336;">${val.failBoth}</td></tr>`;
        });
        html += '</table></div>';

        html += '<div style="margin-bottom: 15px;"><strong>By chroma profile:</strong><table style="width: 100%; margin-top: 5px; border-collapse: collapse;">';
        html += '<tr style="background: #e0e0e0; font-weight: bold;"><td style="padding: 4px; border: 1px solid #ccc;">Chroma profile</td><td style="padding: 4px; border: 1px solid #ccc;">Total</td><td style="padding: 4px; border: 1px solid #ccc; color: #4CAF50;">Pass both</td><td style="padding: 4px; border: 1px solid #ccc; color: #FF9800;">Fail Cond 1 only</td><td style="padding: 4px; border: 1px solid #ccc; color: #9C27B0;">Fail Cond 2 only</td><td style="padding: 4px; border: 1px solid #ccc; color: #f44336;">Fail both</td></tr>';
        Object.entries(stats.byChroma).forEach(([key, val]) => {
            html += `<tr><td style="padding: 4px; border: 1px solid #ccc;">${key}</td><td style="padding: 4px; border: 1px solid #ccc;">${val.total}</td><td style="padding: 4px; border: 1px solid #ccc; color: #4CAF50;">${val.passBoth}</td><td style="padding: 4px; border: 1px solid #ccc; color: #FF9800;">${val.failCond1Only}</td><td style="padding: 4px; border: 1px solid #ccc; color: #9C27B0;">${val.failCond2Only}</td><td style="padding: 4px; border: 1px solid #ccc; color: #f44336;">${val.failBoth}</td></tr>`;
        });
        html += '</table></div>';

        html += '<div><strong>By luminance profile:</strong><table style="width: 100%; margin-top: 5px; border-collapse: collapse;">';
        html += '<tr style="background: #e0e0e0; font-weight: bold;"><td style="padding: 4px; border: 1px solid #ccc;">Luminance profile</td><td style="padding: 4px; border: 1px solid #ccc;">Total</td><td style="padding: 4px; border: 1px solid #ccc; color: #4CAF50;">Pass both</td><td style="padding: 4px; border: 1px solid #ccc; color: #FF9800;">Fail Cond 1 only</td><td style="padding: 4px; border: 1px solid #ccc; color: #9C27B0;">Fail Cond 2 only</td><td style="padding: 4px; border: 1px solid #ccc; color: #f44336;">Fail both</td></tr>';
        Object.entries(stats.byLumi).forEach(([key, val]) => {
            html += `<tr><td style="padding: 4px; border: 1px solid #ccc;">${key}</td><td style="padding: 4px; border: 1px solid #ccc;">${val.total}</td><td style="padding: 4px; border: 1px solid #ccc; color: #4CAF50;">${val.passBoth}</td><td style="padding: 4px; border: 1px solid #ccc; color: #FF9800;">${val.failCond1Only}</td><td style="padding: 4px; border: 1px solid #ccc; color: #9C27B0;">${val.failCond2Only}</td><td style="padding: 4px; border: 1px solid #ccc; color: #f44336;">${val.failBoth}</td></tr>`;
        });
        html += '</table></div>';

        document.getElementById('detailedStats').innerHTML = html;
    }

    // Update threshold value and refresh statistics
    function updateThreshold(value) {
        const threshold = parseFloat(value);
        MIN_COLOR_DIFF_THRESHOLD = threshold;
        
        // Sync slider and number input
        document.getElementById('thresholdSlider').value = threshold;
        document.getElementById('thresholdValue').value = threshold;
        
        // Update statistics and apply filter
        updateStatistics();
        applyFilter();
        updateColormapBorders();
    }
    
    // Update interval parameters (k and j) and refresh statistics
    function updateIntervalParams(k, j) {
        const intervalK = parseInt(k);
        const minDiffJ = parseFloat(j);
        
        SAMPLE_INTERVAL_K = intervalK;
        MIN_INTERVAL_DIFF_J = minDiffJ;
        
        // Sync sliders and number inputs
        document.getElementById('intervalKSlider').value = intervalK;
        document.getElementById('intervalKValue').value = intervalK;
        document.getElementById('intervalJSlider').value = minDiffJ;
        document.getElementById('intervalJValue').value = minDiffJ;
        
        // Recalculate condition 2 for all colormaps
        allColormaps.forEach(cm => {
            const hclPalette = cm.colormap.map(color => {
                const lab = d3.lab(color);
                const hcl = d3.hcl(lab);
                return [hcl.h, hcl.c, hcl.l];
            });
            cm.metrics.sample_interval_min_diff = calcSampleIntervalMinDiff(hclPalette, intervalK);
        });
        
        // Update statistics and apply filter
        updateStatistics();
        applyFilter();
        updateColormapBorders();
    }
    
    // Apply filter based on selected mode
    function applyFilter() {
        const filterMode = document.querySelector('input[name="filterMode"]:checked').value;
        
        colormapElements.forEach((elem, idx) => {
            const cm = allColormaps[idx];
            const passCond1 = cm.metrics.smoothness_min_diff >= MIN_COLOR_DIFF_THRESHOLD;
            const passCond2 = cm.metrics.sample_interval_min_diff >= MIN_INTERVAL_DIFF_J;
            
            let shouldShow = false;
            
            if (filterMode === 'all') {
                shouldShow = true;
            } else if (filterMode === 'pass') {
                shouldShow = passCond1 && passCond2;
            } else if (filterMode === 'failCond1') {
                shouldShow = !passCond1 && passCond2;
            } else if (filterMode === 'failCond2') {
                shouldShow = passCond1 && !passCond2;
            } else if (filterMode === 'failBoth') {
                shouldShow = !passCond1 && !passCond2;
            } else if (filterMode === 'failAny') {
                shouldShow = !passCond1 || !passCond2;
            }
            
            elem.style.display = shouldShow ? 'block' : 'none';
        });
    }
    
    // Update colormap border colors based on current threshold
    function updateColormapBorders() {
        colormapElements.forEach((elem, idx) => {
            const cm = allColormaps[idx];
            const passCond1 = cm.metrics.smoothness_min_diff >= MIN_COLOR_DIFF_THRESHOLD;
            const passCond2 = cm.metrics.sample_interval_min_diff >= MIN_INTERVAL_DIFF_J;
            
            let borderColor, badgeColor, badgeText;
            
            if (passCond1 && passCond2) {
                borderColor = '#4CAF50';
                badgeColor = '#4CAF50';
                badgeText = '✅ Pass';
            } else if (!passCond1 && passCond2) {
                borderColor = '#FF9800';
                badgeColor = '#FF9800';
                badgeText = '⚠️ Fail C1';
            } else if (passCond1 && !passCond2) {
                borderColor = '#9C27B0';
                badgeColor = '#9C27B0';
                badgeText = '⚠️ Fail C2';
            } else {
                borderColor = '#f44336';
                badgeColor = '#f44336';
                badgeText = '❌ Fail Both';
            }
            
            // Update border color
            d3.select(elem).style('border-color', borderColor);
            
            // Update badge - find the first div child which is the badge
            d3.select(elem).select('div')
                .style('background', badgeColor)
                .text(badgeText);
        });
    }

    // read all colormaps, find the luminance and chroma range
    // testColormaps()

    function generateStimuli(sample_number = 500) {
        const base_hues = [0, 50, 100, 150, 200, 250, 300].reverse()
        const hue_combinations = [
            base_hues.slice(),
            base_hues.slice(0, 5),
            base_hues.slice(0, 3)
        ];
        const chromas = [20, 120], lumis = [20, 90];
        const chroma_array = [
            [(chromas[0] + chromas[1]) / 2, (chromas[0] + chromas[1]) / 2],
            [chromas[0], (chromas[0] + chromas[1]) / 2],
            [chromas[0], chromas[1]],
            [chromas[0], chromas[1], chromas[0]],
            [chromas[0], chromas[1], chromas[0], chromas[1], chromas[0]]
        ];
        const lumi_array = [
            [(lumis[0] + lumis[1]) / 2, (lumis[0] + lumis[1]) / 2],
            [lumis[0], (lumis[0] + lumis[1]) / 2],
            [lumis[0], lumis[1]],
            [lumis[0], lumis[1], lumis[0]],
            [lumis[0], lumis[1], lumis[0], lumis[1], lumis[0]]
        ];

        // ---------- 插值函数 ----------
        function getInterpolatedValues(arr, num) {
            const step_num = 500;
            let interpolated = [];
            for (let i = 0; i < arr.length - 1; i++) {
                for (let j = 0; j < step_num; j++) {
                    const t = j / step_num;
                    interpolated.push(arr[i] + t * (arr[i + 1] - arr[i]));
                }
            }
            interpolated.push(arr[arr.length - 1]);

            const sampled = [];
            for (let i = 0; i < num; i++) {
                const idx = Math.round(i / (num - 1) * (interpolated.length - 1));
                sampled.push(interpolated[idx]);
            }
            return sampled;
        }

        // ---------- HCL → RGB ----------
        function hclToRgb(h, c, l) {
            const hRad = (h % 360) / 360 * 2 * Math.PI;
            const a = c * Math.cos(hRad);
            const b = c * Math.sin(hRad);

            let y = (l + 16) / 116;
            let x = a / 500 + y;
            let z = y - b / 200;

            const labToXyz = t => (t ** 3 > 0.008856 ? t ** 3 : (t - 16 / 116) / 7.787);
            x = labToXyz(x) * 95.047;
            y = labToXyz(y) * 100.0;
            z = labToXyz(z) * 108.883;

            let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
            let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
            let b_ = x * 0.0557 + y * -0.2040 + z * 1.0570;

            const gammaCorrect = t => (t > 0.0031308 ? 1.055 * t ** (1 / 2.4) - 0.055 : 12.92 * t);
            r = gammaCorrect(r / 100);
            g = gammaCorrect(g / 100);
            b_ = gammaCorrect(b_ / 100);

            // return {
            //     r: Math.round(Math.max(0, Math.min(1, r)) * 255),
            //     g: Math.round(Math.max(0, Math.min(1, g)) * 255),
            //     b: Math.round(Math.max(0, Math.min(1, b_)) * 255)
            // };
            return { r: r, g: g, b: b_ }
        }

        function isValidRGB(rgb) {
            return (
                !isNaN(rgb.r) && !isNaN(rgb.g) && !isNaN(rgb.b) &&
                isFinite(rgb.r) && isFinite(rgb.g) && isFinite(rgb.b) &&
                rgb.r >= 0 && rgb.r <= 1 &&
                rgb.g >= 0 && rgb.g <= 1 &&
                rgb.b >= 0 && rgb.b <= 1
            );
        }

        // ---------- 找到附近合法颜色 ----------
        const perturbOffsets = [];
        for (let i = -10; i <= 10; i++) {
            for (let j = -30; j <= 30; j++) {
                for (let k = -30; k <= 30; k++) {
                    perturbOffsets.push([i, j, k]);
                }
            }
        }
        perturbOffsets.sort((a, b) =>
            Math.hypot(...a) - Math.hypot(...b)
        );
        console.log("perturbOffsets", perturbOffsets);

        function findNearestValidColor([h, c, l]) {
            // return [h, c, l]
            for (let [dh, dc, dl] of perturbOffsets) {
                const hh = (h + dh + 360) % 360;
                const cc = Math.max(0, Math.min(120, c + dc));
                const ll = Math.max(10, Math.min(90, l + dl));
                const rgb = d3.hcl(hh, cc, ll).rgb();
                if (rgb.displayable()) {
                    return [hh, cc, ll];
                }
            }
            // console.log("No valid color found for HCL:", h, c, l);
            return [h, c, l];
        }
        function getInterpolatedHues(hue_points, num) {
            // 计算插值
            let interpolated = [];
            const step_num = 500;

            for (let i = 0; i < hue_points.length - 1; i++) {
                const h1 = hue_points[i];
                const h2 = hue_points[i + 1];
                let hue

                for (let j = 0; j < step_num; j++) {
                    if (h2 < h1)
                        hue = (h1 + (h2 - h1) * j / step_num) % 360
                    else
                        hue = (h1 + (h2 - h1 - 360) * j / step_num + 360) % 360
                    interpolated.push(hue);
                }
            }

            interpolated.push(hue_points[hue_points.length - 1]);

            // 重采样为固定数量
            const sampled = [];
            for (let i = 0; i < num; i++) {
                const idx = Math.round(i / (num - 1) * (interpolated.length - 1));
                sampled.push(interpolated[idx]);
            }

            return sampled;
        }

        // ---------- 生成 colormap ----------
        const colormap_array = [], condition_array = [], origin_colormap_array = [];
        let colormap_count = 0
        for (let h_index = 0; h_index < hue_combinations.length; h_index++) {
            const hue_base = hue_combinations[h_index].slice();
            const offset = 0; //Math.random() * (h_index === 0 ? 60 : h_index === 1 ? 160 : 260);
            for (let i = 0; i < hue_base.length; i++) {
                hue_base[i] = (hue_base[i] + offset) % 360;
            }

            const hues = getInterpolatedHues(hue_base, sample_number);

            for (let lumi of lumi_array) {
                const luminances = getInterpolatedValues(lumi, sample_number);
                for (let chroma of chroma_array) {
                    const chromas = getInterpolatedValues(chroma, sample_number);

                    const colormap = [], origin_colormap = [];
                    let invalidCount = 0;

                    for (let i = 0; i < sample_number; i++) {
                        const hcl = [hues[i], chromas[i], luminances[i]];
                        origin_colormap.push(hcl);

                        if (true) {
                            const rgb = d3.hcl(...hcl).rgb();
                            if (!rgb.displayable()) {
                                invalidCount++;
                                const adjusted = findNearestValidColor(hcl);
                                colormap.push(adjusted);
                            } else {
                                colormap.push(hcl);
                            }
                        } else {
                            const rgb = d3.rgb(d3.lab(d3.hcl(hcl[0], hcl[1], hcl[2])));
                            const hcl_adjusted = d3.hcl(d3.lab(rgb));
                            colormap.push([hcl_adjusted.h, hcl_adjusted.c, hcl_adjusted.l]);
                        }
                    }

                    console.log(`${colormap_count++} HueSet${h_index}, L=${lumi}, C=${chroma} → Invalid ${invalidCount}/${sample_number}`);
                    colormap_array.push(colormap);
                    condition_array.push(`H=${hue_base}, L=[${lumi}], C=[${chroma}]`);
                    origin_colormap_array.push(origin_colormap)
                }
            }
        }

        return [colormap_array, condition_array, origin_colormap_array];
    }


    function drawGivenCurve(data, div, name, x = 0, y = 1) {
        var svg_width = 400, svg_height = 200, margin = 30
        let linechart_svg = div.append("svg").attr("id", "renderSvg").attr("typeId", "line")
            .attr("width", svg_width).attr("height", svg_height).style("display", "inline-block");

        let linechart = linechart_svg.style("background-color", "#FFF")
            .append("g")
            .attr("transform", "translate(" + margin + "," + margin + ")");

        let m_xScale = d3.scaleLinear().range([0, svg_width - margin * 2]), // value -> display
            m_yScale = d3.scaleLinear().range([svg_height - margin * 2, 0]); // value -> display
        // Scale the range of the data
        m_xScale.domain(d3.extent(data[0], function (d) {
            return d[x];
        }));

        const yMin = d3.min(data, line => d3.min(line, d => d[y]));
        const yMax = d3.max(data, line => d3.max(line, d => d[y]));
        const yRange = yMax - yMin;
        const padding = yRange === 0 ? (yMin === 0 ? 1 : Math.abs(yMin) * 0.1) : yRange * 0.1;
        m_yScale.domain([yMin - padding, yMax + padding]);

        // define the line
        let valueline = d3.line()
            .x(function (d) {
                return m_xScale(d[x]);
            })
            .y(function (d) {
                return m_yScale(d[y]);
            })//.curve(d3.curveCatmullRom);

        // Add the valueline path.
        linechart.selectAll('path')
            .data(data).enter().append("path")
            .attr("d", function (d) {
                return valueline(d);
            })
            .attr("class", "linechart")
            .attr("fill", "none")
            // .attr("stroke", "#444")
            .attr("stroke", function (d, i) {
                return i == 0 ? "blue" : "red"
            })
            .style("stroke-width", 1)

        // Add the X Axis
        linechart.append("g")
            .attr("transform", "translate(0," + (svg_height - margin * 2) + ")")
            .call(d3.axisBottom(m_xScale)); //.tickFormat("")

        // Add the Y Axis
        linechart.append("g")
            .call(d3.axisLeft(m_yScale)); //.tickFormat("")

        linechart_svg.append("text").attr("x", 0).attr("y", 20).text(name)
            .attr("font-size", "12px").attr("fill", "#000")
            .attr("text-anchor", "start").attr("font-weight", "bold")
            .attr("transform", "translate(" + (margin) + "," + (margin - 10) + ")");
    }

    function drawGivenColormap(colormap, condition_name, condition) {
        let div = d3.select("body").append("div")
            .style("border", "1px solid black").style("margin-top", "10px")
            .style("padding", "5px")
        div.append("h3").text(condition_name)

        function getCurve(pal, index) {
            var curve = []
            for (var i = 0; i < pal.length; i++) {
                let tuple = d3.rgb(d3.lab(d3.hcl(pal[i][0], pal[i][1], pal[i][2])))
                let hcl = d3.hcl(d3.lab(tuple))
                tuple = [hcl.h, hcl.c, hcl.l]
                curve.push([i, tuple[index]])
            }
            return curve
        }
        function getCurve2(pal, index) {
            var curve = []
            for (var i = 0; i < pal.length; i++) {
                curve.push([i, pal[i][index]])
            }
            return curve
        }
        drawGivenCurve([getCurve2(condition, 0), getCurve(colormap, 0)], div, "Hue")
        drawGivenCurve([getCurve2(condition, 1), getCurve(colormap, 1)], div, "chroma")
        drawGivenCurve([getCurve2(condition, 2), getCurve(colormap, 2)], div, "luminance")

        let width = colormap.length, height = 45
        //get context 
        div.append("canvas").attr("id", condition_name)
            .attr("width", width).attr("height", height).style("margin-left", "20px")
        let canvas = document.getElementById(condition_name)
        let context = canvas.getContext('2d');

        //traverse the image data
        for (var i = 0; i < canvas.width; i++) {
            let tuple = d3.rgb(d3.lab(d3.hcl(colormap[i][0], colormap[i][1], colormap[i][2])))
            for (var j = 0; j < canvas.height; j++) {
                context.fillStyle = 'rgba(' + tuple.r +
                    ',' + tuple.g +
                    ',' + tuple.b +
                    ',' + 1 + ')';
                context.fillRect(i, j, 1, 1);
            }
        }

    }

    function getInterpolatedRgb(colormap, step_num) {
        const interpolated = [];
        for (let i = 0; i < colormap.length - 1; i++) {
            const start = colormap[i];
            const end = colormap[i + 1];
            for (let j = 0; j < step_num; j++) {
                const t = j / step_num;
                const r = Math.round(start.r + t * (end.r - start.r));
                const g = Math.round(start.g + t * (end.g - start.g));
                const b = Math.round(start.b + t * (end.b - start.b));
                interpolated.push(d3.rgb(r, g, b));
            }
        }
        // 重采样为固定数量
        const sampled = [];
        for (let i = 0; i < step_num; i++) {
            const idx = Math.round(i / (step_num - 1) * (interpolated.length - 1));
            sampled.push(interpolated[idx]);
        }
        return sampled;
    }

    // // 生成少量控制点，在每个控制点之间使用rgb插值
    // let stimuli_array = generateStimuli(100)
    // for (let i = 0; i < stimuli_array[0].length; i++) {
    //     let colormap = stimuli_array[0][i]
    //     // test
    //     const colormap_rgb = colormap.map(d => d3.rgb(d3.lab(d3.hcl(d[0], d[1], d[2]))))
    //     let interpolated = getInterpolatedRgb(colormap_rgb, 500)
    //     const colormap_hcl = interpolated.map(d => {
    //         const hcl = d3.hcl(d3.lab(d));
    //         return [hcl.h, hcl.c, hcl.l];
    //     })
    //     const condition_interpolated = [];
    //     for (let j = 0; j < 500; j++) {
    //         const t = j / 499; // Normalize to [0, 1]
    //         const index = t * (stimuli_array[2][i].length - 1);
    //         const lowerIndex = Math.floor(index);
    //         const upperIndex = Math.ceil(index);
    //         const ratio = index - lowerIndex;

    //         const lower = stimuli_array[2][i][lowerIndex];
    //         const upper = stimuli_array[2][i][upperIndex];

    //         condition_interpolated.push([
    //             lower[0] + ratio * (upper[0] - lower[0]),
    //             lower[1] + ratio * (upper[1] - lower[1]),
    //             lower[2] + ratio * (upper[2] - lower[2])
    //         ]);
    //     }
    //     stimuli_array[2][i] = condition_interpolated;
    //     drawGivenColormap(colormap_hcl, i + "：" + stimuli_array[1][i], stimuli_array[2][i])
    // }

    // let stimuli_array = generateStimuli(500)
    // for (let i = 0; i < stimuli_array[0].length; i++) {
    //     let colormap = stimuli_array[0][i]
    //     drawGivenColormap(colormap, i + "：" + stimuli_array[1][i], stimuli_array[2][i])
    // }
</script>

<script>
    function parseControlPoints(input) {
        const min = Math.min(...input);
        const max = Math.max(...input);
        if (max > min) {
            input = input.map(v => (v - min) / (max - min));
        } else {
            input = input.map(() => 0.5); // Default to 0.5 if all values are the same
        }
        return input
        // return input.map(d => +d / 100).map(v => Math.max(0, Math.min(1, v)));
    }

    function ciede2000(lab1, lab2) {
        const [L1, a1, b1] = lab1;
        const [L2, a2, b2] = lab2;

        const avg_L = (L1 + L2) / 2.0;
        const C1 = Math.sqrt(a1 * a1 + b1 * b1);
        const C2 = Math.sqrt(a2 * a2 + b2 * b2);
        const avg_C = (C1 + C2) / 2.0;

        const G = 0.5 * (1 - Math.sqrt((avg_C ** 7) / ((avg_C ** 7) + (25 ** 7))));
        const a1p = (1 + G) * a1;
        const a2p = (1 + G) * a2;
        const C1p = Math.sqrt(a1p * a1p + b1 * b1);
        const C2p = Math.sqrt(a2p * a2p + b2 * b2);

        const avg_Cp = (C1p + C2p) / 2.0;

        const h1 = Math.atan2(b1, a1p), h2 = Math.atan2(b2, a2p)
        const h1p = h1 * 180 / Math.PI + (h1 < 0 ? 360 : 0);
        const h2p = h2 * 180 / Math.PI + (h2 < 0 ? 360 : 0);

        const deltahp = (C1p * C2p === 0) ? 0 :
            (Math.abs(h2p - h1p) <= 180) ? (h2p - h1p) :
                (h2p <= h1p) ? (h2p - h1p + 360) : (h2p - h1p - 360);

        const deltaLp = L2 - L1;
        const deltaCp = C2p - C1p;
        const deltaHp = 2 * Math.sqrt(C1p * C2p) * Math.sin((deltahp * Math.PI) / 360);

        const avg_Lp = (L1 + L2) / 2.0;
        // const avg_hp = (Math.abs(h1p - h2p) > 180) ? (h1p + h2p + 360) / 2.0 : (h1p + h2p) / 2.0;
        let avg_hp;
        if (Math.abs(h1p - h2p) <= 180) {
            avg_hp = (h1p + h2p) / 2.0;
        } else if ((h1p + h2p) < 360) {
            avg_hp = (h1p + h2p + 360) / 2.0;
        } else {
            avg_hp = (h1p + h2p - 360) / 2.0;
        }

        const T = 1
            - 0.17 * Math.cos((avg_hp - 30) * Math.PI / 180)
            + 0.24 * Math.cos((2 * avg_hp) * Math.PI / 180)
            + 0.32 * Math.cos((3 * avg_hp + 6) * Math.PI / 180)
            - 0.20 * Math.cos((4 * avg_hp - 63) * Math.PI / 180);

        const delta_ro = 30 * Math.exp(-(((avg_hp - 275) / 25) ** 2));
        const RC = 2 * Math.sqrt((avg_Cp ** 7) / ((avg_Cp ** 7) + (25 ** 7)));
        const SL = 1 + (0.015 * ((avg_Lp - 50) ** 2)) / Math.sqrt(20 + ((avg_Lp - 50) ** 2));
        const SC = 1 + 0.045 * avg_Cp;
        const SH = 1 + 0.015 * avg_Cp * T;
        const RT = -Math.sin(2 * delta_ro * Math.PI / 180) * RC;

        const deltaE = Math.sqrt(
            (deltaLp / SL) ** 2 +
            (deltaCp / SC) ** 2 +
            (deltaHp / SH) ** 2 +
            RT * (deltaCp / SC) * (deltaHp / SH)
        );

        return deltaE;
    }

    // Calculate min color diff for samples at interval k
    function calcSampleIntervalMinDiff(palette, intervalK) {
        let min_interval_diff = Number.MAX_VALUE;
        try {
            // Generate fine samples using JND-based sampling
            let fineSamples = [];
            let numFineSamples = 1000;
            for (let k = 0; k < numFineSamples; k++) {
                let t_total = k / (numFineSamples - 1); 
                let segmentIndex = Math.floor(t_total * (palette.length - 1));
                if (segmentIndex >= palette.length - 1) segmentIndex = palette.length - 2;
                let segmentLength = 1 / (palette.length - 1);
                let t = (t_total - segmentIndex * segmentLength) / segmentLength;
                
                let c1 = palette[segmentIndex];
                let c2 = palette[segmentIndex + 1];
                
                let h1 = c1[0], h2 = c2[0];
                let diff = h2 - h1;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                let h = (h1 + diff * t + 360) % 360;
                let c = c1[1] + (c2[1] - c1[1]) * t;
                let l = c1[2] + (c2[2] - c1[2]) * t;
                
                fineSamples.push(d3.lab(d3.hcl(h, c, l)));
            }

            let jndStep = 3.0;
            let samples = [];
            if (fineSamples.length > 0) {
                samples.push(fineSamples[0]);
                let lastSample = fineSamples[0];
                
                for (let i = 1; i < fineSamples.length; i++) {
                    let current = fineSamples[i];
                    let dist = ciede2000([lastSample.l, lastSample.a, lastSample.b], [current.l, current.a, current.b]);
                    if (dist >= jndStep) {
                        samples.push(current);
                        lastSample = current;
                    }
                }
                if (samples.length < 2 && fineSamples.length > 1) {
                    samples.push(fineSamples[fineSamples.length - 1]);
                }
            }
            
            if (samples.length < intervalK + 1) {
                return 0;
            }

            // Check color diff between samples at interval k
            for (let i = 0; i + intervalK < samples.length; i++) {
                let deltaE = ciede2000(
                    [samples[i].l, samples[i].a, samples[i].b],
                    [samples[i + intervalK].l, samples[i + intervalK].a, samples[i + intervalK].b]
                );
                if (deltaE < min_interval_diff) {
                    min_interval_diff = deltaE;
                }
            }
            
            if (min_interval_diff === Number.MAX_VALUE) min_interval_diff = 0;
            
        } catch (e) {
            console.warn("Error in interval diff calculation:", e);
            return 0;
        }
        return min_interval_diff;
    }

    function calcSmoothnessMinDiff(palette) {
        let min_color_diff = 0;
        try {
            let fineSamples = [];
            let numFineSamples = 1000;
            for (let k = 0; k < numFineSamples; k++) {
                let t_total = k / (numFineSamples - 1); 
                let segmentIndex = Math.floor(t_total * (palette.length - 1));
                if (segmentIndex >= palette.length - 1) segmentIndex = palette.length - 2;
                let segmentLength = 1 / (palette.length - 1);
                let t = (t_total - segmentIndex * segmentLength) / segmentLength;
                
                let c1 = palette[segmentIndex];
                let c2 = palette[segmentIndex + 1];
                
                let h1 = c1[0], h2 = c2[0];
                let diff = h2 - h1;
                if (diff > 180) diff -= 360;
                if (diff < -180) diff += 360;
                let h = (h1 + diff * t + 360) % 360;
                let c = c1[1] + (c2[1] - c1[1]) * t;
                let l = c1[2] + (c2[2] - c1[2]) * t;
                
                fineSamples.push(d3.lab(d3.hcl(h, c, l)));
            }

            let jndStep = 3.0;
            let samples = [];
            if (fineSamples.length > 0) {
                samples.push(fineSamples[0]);
                let lastSample = fineSamples[0];
                
                for (let i = 1; i < fineSamples.length; i++) {
                    let current = fineSamples[i];
                    let dist = ciede2000([lastSample.l, lastSample.a, lastSample.b], [current.l, current.a, current.b]);
                    if (dist >= jndStep) {
                        samples.push(current);
                        lastSample = current;
                    }
                }
                if (samples.length < 2 && fineSamples.length > 1) {
                    samples.push(fineSamples[fineSamples.length - 1]);
                }
            }
            
            if (samples.length < 2) return 0;

            let minDeltaE = Number.MAX_VALUE;
            
            for (let i = 0; i < samples.length; i++) {
                for (let j = i + 1; j < samples.length; j++) {
                    let deltaE = ciede2000([samples[i].l, samples[i].a, samples[i].b], [samples[j].l, samples[j].a, samples[j].b]);
                    if (deltaE < minDeltaE) {
                        minDeltaE = deltaE;
                    }
                }
            }
            
            if (minDeltaE === Number.MAX_VALUE) minDeltaE = 0;
            min_color_diff = minDeltaE;
            
        } catch (e) {
            console.warn("Error in smoothness calculation:", e);
        }
        return min_color_diff;
    }

    function satisfyDiscriminability(colormap, sampleNum = 10) {
        const sampled_colormap = [];
        for (let i = 0; i < colormap.length; i += Math.floor(colormap.length / sampleNum)) {
            let lab = d3.lab(colormap[i]);
            sampled_colormap.push([lab.l, lab.a, lab.b]);
        }

        for (let i = 0; i < sampled_colormap.length; i++) {
            for (let j = i + 1; j < sampled_colormap.length; j++) {
                let deltaE = ciede2000(sampled_colormap[i], sampled_colormap[j])
                if (deltaE < 3) {
                    // console.log("discriminable", i, j, deltaE)
                    return false
                }
            }
        }
        return true
    }

    function generate(targetH, targetC, targetL, controlPoints_c, controlPoints_l) {
        if (targetC < 0 || targetL < 0) return []
        const cControls = parseControlPoints(controlPoints_c);
        const lControls = parseControlPoints(controlPoints_l);
        // console.log(targetH, targetC, targetL, cControls, lControls);
        let hue_start = Math.random() * 360

        const sampleN = 256;
        const step = 5;
        const candidates = [];

        for (let hStart = 0; hStart <= 360; hStart += step) {
            for (let cBase = 20; cBase <= 130 - targetC; cBase += step) {
                for (let lBase = 20; lBase <= 100 - targetL; lBase += step) {
                    const hEnd = (hue_start + hStart - targetH + 360) % 360;
                    const colormap = [];
                    const hValues = [], cValues = [], lValues = [];

                    for (let i = 0; i < sampleN; i++) {
                        const t = i / (sampleN - 1);
                        const h1 = (hue_start + hStart) % 360;
                        const h2 = hEnd;
                        let hue
                        if (h2 < h1)
                            hue = (h1 + (h2 - h1) * t) % 360
                        else
                            hue = (h1 + (h2 - h1 - 360) * t + 360) % 360
                        const h = hue

                        const cInterp = interpolateMultiSegment(t, cControls);
                        const cMin = d3.min(cControls), cMax = d3.max(cControls);
                        let cNorm = (cInterp - cMin) / Math.max(1e-5, cMax - cMin);
                        let c = cBase + targetC * cNorm;
                        if (controlPoints_c[0] == controlPoints_c[1]) {
                            c = 20 - cBase + controlPoints_c[0]
                        }

                        const lInterp = interpolateMultiSegment(t, lControls);
                        const lMin = d3.min(lControls), lMax = d3.max(lControls);
                        let lNorm = (lInterp - lMin) / Math.max(1e-5, lMax - lMin);
                        let l = lBase + targetL * lNorm;
                        if (controlPoints_l[0] == controlPoints_l[1]) {
                            l = 20 - lBase + controlPoints_l[0]
                        }

                        const rgb = d3.hcl(h, c, l).rgb();
                        if (!rgb.displayable()) break;
                        colormap.push(d3.rgb(rgb.r, rgb.g, rgb.b));
                        hValues.push(h);
                        cValues.push(c);
                        lValues.push(l);
                    }

                    if (colormap.length === sampleN && satisfyDiscriminability(colormap)) {
                        candidates.push({ colormap, hValues, cValues, lValues });
                        // if (candidates.length >= 10) break;
                    }
                }
            }
        }

        // 排序候选 colormap 按 chroma 和 luminance 误差最小优先
        candidates.sort((a, b) => {
            const errA = Math.abs(d3.max(a.cValues) - d3.max(controlPoints_c) + d3.min(controlPoints_c) - d3.min(a.cValues)) +
                Math.abs(d3.max(a.lValues) - d3.max(controlPoints_l) + d3.min(controlPoints_l) - d3.min(a.lValues));
            const errB = Math.abs(d3.max(b.cValues) - d3.max(controlPoints_c) + d3.min(controlPoints_c) - d3.min(b.cValues)) +
                Math.abs(d3.max(b.lValues) - d3.max(controlPoints_l) + d3.min(controlPoints_l) - d3.min(b.lValues));
            return errA - errB;
        });

        // 添加误差提示信息
        candidates.forEach((cand, i) => {
            const cRange = d3.max(cand.cValues) - d3.min(cand.cValues);
            const lRange = d3.max(cand.lValues) - d3.min(cand.lValues);
            const cErr = (cRange - targetC).toFixed(2);
            const lErr = (lRange - targetL).toFixed(2);
            cand.label = `Colormap ${i + 1} | ΔC err: ${cErr}, ΔL err: ${lErr}`;
        });

        return candidates;
    }

    function interpolateMultiSegment(t, points) {
        const seg = points.length - 1;
        const segT = t * seg;
        const idx = Math.floor(segT);
        const frac = segT - idx;
        const p0 = points[idx] ?? points[points.length - 1];
        const p1 = points[idx + 1] ?? points[points.length - 1];
        return (p0 + frac * (p1 - p0)); // strictly normalized to [0,1]
    }

    function generateAll() {
        // Reset global arrays
        allColormaps = [];
        colormapElements = [];
        
        // Remove existing grid if present
        d3.select("#colormapsGrid").remove();
        
        // Create grid container for multi-column layout
        d3.select("body").append("div")
            .attr("id", "colormapsGrid")
            .style("display", "grid")
            .style("grid-template-columns", "repeat(auto-fill, minmax(400px, 1fr))")
            .style("gap", "15px")
            .style("padding", "20px")
            .style("max-width", "100%");

        const hue_targets = [100, 200, 300]

        // Profile Definitions
        // Constant: value = 55 (L), 70 (C)
        // Linear: range = [20, 90] (L), [20, 120] (C)
        // Diverging: range = [20, 90, 20] (L), [20, 120, 20] (C)
        // Thermal: range = [20, 90, 20, 90, 20] (L), [20, 120, 20, 120, 20] (C)

        const chromas = [20, 120], lumis = [20, 90];
        
        const chroma_array = [
            [70, 70],                                   // Constant
            [chromas[0], chromas[1]],                   // Linear
            [chromas[0], chromas[1], chromas[0]],       // Diverging
            [chromas[0], chromas[1], chromas[0], chromas[1], chromas[0]] // Thermal
        ];
        
        const lumi_array = [
            [55, 55],                                   // Constant
            [lumis[0], lumis[1]],                       // Linear
            [lumis[0], lumis[1], lumis[0]],             // Diverging
            [lumis[0], lumis[1], lumis[0], lumis[1], lumis[0]] // Thermal
        ];

        const perturbOffsets = [];
        for (let i = 0; i <= 70; i += 5) {
            for (let j = 0; j <= 50; j += 5) {
                perturbOffsets.push([i, j]);
            }
        }
        perturbOffsets.sort((a, b) =>
            Math.hypot(...a) - Math.hypot(...b)
        );
        console.log("perturbOffsets", perturbOffsets);
        let colormap_count = 0
        let hue_index = 0;
        for (let hue of hue_targets) {
            for (let lumi of lumi_array) {
                let luminance_target = lumi[1] - lumi[0];
                for (let chroma of chroma_array) {
                    let chroma_target = chroma[1] - chroma[0];
                    let used_chroma = chroma_target, used_lumi = luminance_target;
                    let colormap
                    for (let i = 0; i < perturbOffsets.length; i++) {
                        used_chroma = Math.max(0, chroma_target - perturbOffsets[i][0]);
                        used_lumi = Math.max(0, luminance_target - perturbOffsets[i][1]);
                        colormap = generate(hue, used_chroma, used_lumi, chroma, lumi);
                        if (colormap.length > 0) {
                            break;
                        }
                    }
                    if (colormap.length > 0) {
                        const condition = `H diff=${hue}, C=[${chroma}], L=[${lumi}]` + ", chroma diff=" + used_chroma + `(${chroma_target})` + ", lumi diff=" + used_lumi + `(${luminance_target})`;
                        drawGivenColormap2(colormap[0], (colormap_count++) + ", " + condition);
                    }
                }
            }
            hue_index++;
        }
        
        // Update statistics after all colormaps are generated
        updateStatistics();
    }

    function getHueDiff(h1, h2) {
        return (h1 - h2 + 360) % 360
    }
    function drawGivenCurve2(data, div, name, x = 0, y = 1) {

        var svg_width = 220, svg_height = 80, margin = 20
        let linechart_svg = div.append("svg").attr("id", "renderSvg").attr("typeId", "line")
            .attr("width", svg_width).attr("height", svg_height)
            .style("display", "block")
            .style("flex", "1")
            .style("min-width", "180px");

        let linechart = linechart_svg.style("background-color", "#FFF")
            .append("g")
            .attr("transform", "translate(" + margin + "," + margin + ")");

        let m_xScale = d3.scaleLinear().range([0, svg_width - margin * 2]), // value -> display
            m_yScale = d3.scaleLinear().range([svg_height - margin * 2, 0]); // value -> display
        // Scale the range of the data
        m_xScale.domain([0, data[0].length - 1]);
        
        const yMin = d3.min(data, line => d3.min(line));
        const yMax = d3.max(data, line => d3.max(line));
        const yRange = yMax - yMin;
        const padding = yRange === 0 ? (yMin === 0 ? 1 : Math.abs(yMin) * 0.1) : yRange * 0.1;
        m_yScale.domain([yMin - padding, yMax + padding]);

        // define the line
        let valueline = d3.line()
            .x(function (d, i) {
                return m_xScale(i);
            })
            .y(function (d) {
                return m_yScale(d);
            })//.curve(d3.curveCatmullRom);

        // Add the valueline path.
        linechart.selectAll('path')
            .data(data).enter().append("path")
            .attr("d", function (d) {
                return valueline(d);
            })
            .attr("class", "linechart")
            .attr("fill", "none")
            // .attr("stroke", "#444")
            .attr("stroke", function (d, i) {
                return i == 0 ? "blue" : "red"
            })
            .style("stroke-width", 1)

        // Add the X Axis
        linechart.append("g")
            .attr("transform", "translate(0," + (svg_height - margin * 2) + ")")
            .call(d3.axisBottom(m_xScale))
            .style("font-size", "8px"); //.tickFormat("")

        // Add the Y Axis
        linechart.append("g")
            .call(d3.axisLeft(m_yScale))
            .style("font-size", "8px"); //.tickFormat("")

        linechart_svg.append("text").attr("x", 0).attr("y", 15).text(name)
            .attr("font-size", "10px").attr("fill", "#000")
            .attr("text-anchor", "start").attr("font-weight", "bold")
            .attr("transform", "translate(" + (margin) + "," + (margin - 8) + ")");
    }

    function drawGivenColormap2(candidates, condition_name) {
        const colormap = candidates['colormap'];
        let div = d3.select("#colormapsGrid").append("div").attr("class", "colormapDiv")
            .style("border", "1px solid #ccc").style("margin-top", "10px")
            .style("padding", "10px").style("background", "#fafafa")
            .style("border-radius", "4px").style("box-shadow", "0 2px 4px rgba(0,0,0,0.1)")
            .style("display", "grid")
            .style("grid-template-columns", "1fr")
            .style("gap", "10px")
            .style("width", "100%")
            .style("max-width", "400px");

        // Add title
        div.append("div")
            .style("font-size", "11px")
            .style("color", "#666")
            .style("margin-bottom", "5px")
            .text(condition_name);

        // Canvas at top (below title)
        let width = colormap.length, height = 40;
        // Use a unique numeric ID to avoid issues with special characters
        const canvasId = "canvas_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
        div.append("canvas").attr("id", canvasId)
            .attr("width", width).attr("height", height)
            .style("display", "block")
            .style("margin", "0");
        let canvas = document.getElementById(canvasId);
        let context = canvas.getContext('2d');

        //traverse the image data
        for (var i = 0; i < canvas.width; i++) {
            let tuple = colormap[i];
            for (var j = 0; j < canvas.height; j++) {
                context.fillStyle = 'rgba(' + tuple.r +
                    ',' + tuple.g +
                    ',' + tuple.b +
                    ',' + 1 + ')';
                context.fillRect(i, j, 1, 1);
            }
        }

        // Charts container (horizontal flex layout)
        let chartsDiv = div.append("div")
            .style("display", "flex")
            .style("gap", "10px")
            .style("justify-content", "space-between")
            .style("flex-wrap", "wrap");

        drawGivenCurve2([candidates['hValues']], chartsDiv, "Hue");
        drawGivenCurve2([candidates['cValues']], chartsDiv, "Chroma");
        drawGivenCurve2([candidates['lValues']], chartsDiv, "Luminance");

        // Calculate and display metrics
        const metrics = calculateAndDisplayMetrics(colormap, condition_name);
        if (metrics) {
            displayMetricsInDiv(div, metrics);
            
            // Store colormap data for statistics
            const divNode = div.node();
            allColormaps.push({
                colormap: colormap,
                metrics: metrics,
                chromaLabel: 'Unknown',
                lumiLabel: 'Unknown',
                hueCount: 1,
                condition: condition_name
            });
            colormapElements.push(divNode);
            
            // Update border color based on Min Color Diff threshold
            const isPassing = metrics.smoothness_min_diff >= MIN_COLOR_DIFF_THRESHOLD;
            div.style("border-color", isPassing ? "#4CAF50" : "#f44336")
               .style("border-width", "3px");
            
            // Add status badge
            div.insert("div", ":first-child")
                .style("position", "absolute")
                .style("top", "5px")
                .style("right", "5px")
                .style("padding", "4px 8px")
                .style("border-radius", "3px")
                .style("font-size", "11px")
                .style("font-weight", "bold")
                .style("background", isPassing ? "#4CAF50" : "#f44336")
                .style("color", "white")
                .text(isPassing ? " Pass" : " Fail");
            
            div.style("position", "relative");
        }
    }

// ========== Static Metrics Calculation Functions ==========

    // 辅助函数：将 RGB colormap 转换为标准格式
    function convertColormapToStandardFormat(colormap) {
        if (!colormap || colormap.length === 0) {
            console.error("Invalid colormap:", colormap);
            return null;
        }

        const standardizedColors = [];
        for (let i = 0; i < colormap.length; i++) {
            const color = colormap[i];
            let r, g, b;

            if (typeof color.r === 'number' && typeof color.g === 'number' && typeof color.b === 'number') {
                r = Math.round(color.r);
                g = Math.round(color.g);
                b = Math.round(color.b);
            } else if (Array.isArray(color) && color.length >= 3) {
                r = Math.round(color[0]);
                g = Math.round(color[1]);
                b = Math.round(color[2]);
            } else {
                console.warn(`Invalid color at index ${i}:`, color);
                continue;
            }

            standardizedColors.push({
                value: i / (colormap.length - 1),
                rgb: [r, g, b]
            });
        }

        if (standardizedColors.length === 0) {
            console.error("No valid colors found in colormap");
            return null;
        }

        return standardizedColors;
    }

    // 简化的 ΔE 计算 (用于对比敏感度)
    function computeDeltaE(L1, a1, b1, L2, a2, b2, wa = 0.1, wb = 0.1) {
        if (isNaN(L1) || isNaN(a1) || isNaN(b1) || isNaN(L2) || isNaN(a2) || isNaN(b2)) {
            console.error("computeDeltaE received invalid parameters:", { L1, a1, b1, L2, a2, b2 });
            return 0;
        }

        let deltaL = L1 - L2;
        let deltaA = a1 - a2;
        let deltaB = b1 - b2;

        if (isNaN(deltaL) || isNaN(deltaA) || isNaN(deltaB)) {
            console.error("computeDeltaE calculation error:", { deltaL, deltaA, deltaB });
            return 0;
        }

        const result = Math.sqrt(
            Math.pow(deltaL, 2) +
            wa * Math.pow(deltaA, 2) +
            wb * Math.pow(deltaB, 2)
        );

        if (isNaN(result)) {
            console.error("computeDeltaE final result is NaN");
            return 0;
        }

        return result;
    }

    // 1. CIEDE2000 Discriminative Power
    function discriminatory_cie(colormap) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            console.error("Invalid colors array:", colors);
            return 0;
        }

        let totalSpeed = 0;
        let pairCount = 0;

        for (let i = 0; i < colors.length; i++) {
            for (let j = i + 1; j < colors.length; j++) {
                const rgbColor1 = d3.rgb(colors[i].rgb[0], colors[i].rgb[1], colors[i].rgb[2]);
                const rgbColor2 = d3.rgb(colors[j].rgb[0], colors[j].rgb[1], colors[j].rgb[2]);
                const lab1 = d3.lab(rgbColor1);
                const lab2 = d3.lab(rgbColor2);

                const deltaE = ciede2000([lab1.l || lab1.L, lab1.a, lab1.b], [lab2.l || lab2.L, lab2.a, lab2.b]);
                const v_ij = deltaE;
                totalSpeed += v_ij;
                pairCount++;
            }
        }

        const globalDiscriminativePower = pairCount > 0 ? totalSpeed / pairCount : 0;
        return globalDiscriminativePower;
    }

    // 2. Contrast Sensitivity
    function discriminatory_contrast_sensitivity(colormap) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            console.error("Invalid colors array:", colors);
            return 0;
        }

        let totalSpeed = 0;
        let pairCount = 0;

        try {
            for (let i = 0; i < colors.length; i++) {
                for (let j = i + 1; j < colors.length; j++) {
                    try {
                        const rgbColor1 = d3.rgb(colors[i].rgb[0], colors[i].rgb[1], colors[i].rgb[2]);
                        const rgbColor2 = d3.rgb(colors[j].rgb[0], colors[j].rgb[1], colors[j].rgb[2]);

                        if (!rgbColor1 || !rgbColor2) {
                            continue;
                        }

                        const lab1 = d3.lab(rgbColor1);
                        const lab2 = d3.lab(rgbColor2);

                        const l1 = Number(lab1.l !== undefined ? lab1.l : lab1.L);
                        const a1 = Number(lab1.a);
                        const b1 = Number(lab1.b);
                        const l2 = Number(lab2.l !== undefined ? lab2.l : lab2.L);
                        const a2 = Number(lab2.a);
                        const b2 = Number(lab2.b);

                        const deltaE = computeDeltaE(l1, a1, b1, l2, a2, b2);

                        if (isNaN(deltaE) || deltaE === 0) {
                            continue;
                        }

                        const normalizationFactor = Math.abs((j - i) / (colors.length - 1));

                        if (normalizationFactor === 0) {
                            continue;
                        }

                        const v_ij = deltaE / normalizationFactor;

                        if (isNaN(v_ij)) {
                            continue;
                        }

                        const contribution = 3.4 * Math.pow(v_ij, 0.879);

                        totalSpeed += contribution;
                        pairCount++;

                    } catch (error) {
                        console.error(`Error processing color pair [${i}, ${j}]:`, error);
                    }
                }
            }

            const globalDiscriminativePower = pairCount > 0 ? totalSpeed / pairCount : 0;
            return globalDiscriminativePower;
        } catch (error) {
            console.error("discriminatory_contrast_sensitivity error:", error);
            return 0;
        }
    }

    // 3. Hue Variation
    function discriminatory_hue(colormap) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            console.error("Invalid colors array:", colors);
            return 0;
        }

        const hueValues = [];
        for (let i = 0; i < colors.length; i++) {
            try {
                const r = parseInt(colors[i].rgb[0]);
                const g = parseInt(colors[i].rgb[1]);
                const b = parseInt(colors[i].rgb[2]);

                if (isNaN(r) || isNaN(g) || isNaN(b)) {
                    continue;
                }

                const rgbColor = d3.rgb(r, g, b);
                const hcl = d3.hcl(rgbColor);

                const h = isNaN(hcl.h) ? 0 : hcl.h;
                hueValues.push(h);
            } catch (error) {
                console.error(`Error processing color ${i}:`, error);
            }
        }

        if (hueValues.length === 0) {
            return 0;
        }

        let totalVariation = 0;
        for (let i = 1; i < hueValues.length; i++) {
            let diff = Math.abs(hueValues[i] - hueValues[i - 1]);
            if (diff > 180) {
                diff = 360 - diff;
            }
            totalVariation += diff;
        }

        return totalVariation;
    }

    // 4. Luminance Variation
    function luminance_variation(colormap) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            console.error("Invalid colors array:", colors);
            return 0;
        }

        const luminanceValues = [];
        for (let i = 0; i < colors.length; i++) {
            try {
                const r = parseInt(colors[i].rgb[0]);
                const g = parseInt(colors[i].rgb[1]);
                const b = parseInt(colors[i].rgb[2]);

                if (isNaN(r) || isNaN(g) || isNaN(b)) {
                    console.error(`Invalid rgb values for color ${i}:`, colors[i].rgb);
                    continue;
                }

                const rgbColor = d3.rgb(r, g, b);
                const hcl = d3.hcl(rgbColor);

                const lValue = hcl.l !== undefined ? hcl.l : hcl.L;
                if (hcl && typeof lValue === 'number' && !isNaN(lValue)) {
                    luminanceValues.push(lValue);
                } else {
                    console.error(`Invalid luminance for color ${i}:`, hcl);
                }
            } catch (error) {
                console.error(`Error processing color ${i}:`, error);
            }
        }

        if (luminanceValues.length === 0) {
            console.error("No valid luminance values calculated");
            return null;
        }

        let totalVariation = 0;
        for (let i = 1; i < luminanceValues.length; i++) {
            totalVariation += Math.abs(luminanceValues[i] - luminanceValues[i - 1]);
        }

        return totalVariation;
    }

    // 5. Chromatic Variation
    function chromatic_variation(colormap) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            console.error("Invalid colors array:", colors);
            return 0;
        }

        const saturationValues = [];
        for (let i = 0; i < colors.length; i++) {
            try {
                const r = parseInt(colors[i].rgb[0]);
                const g = parseInt(colors[i].rgb[1]);
                const b = parseInt(colors[i].rgb[2]);

                if (isNaN(r) || isNaN(g) || isNaN(b)) {
                    console.error(`Invalid rgb values for color ${i}:`, colors[i].rgb);
                    continue;
                }

                const rgbColor = d3.rgb(r, g, b);
                const hcl = d3.hcl(rgbColor);

                const cValue = hcl.c !== undefined ? hcl.c : hcl.C;
                if (hcl && typeof cValue === 'number' && !isNaN(cValue)) {
                    saturationValues.push(cValue);
                } else {
                    console.error(`Invalid saturation for color ${i}:`, hcl);
                }
            } catch (error) {
                console.error(`Error processing color ${i}:`, error);
            }
        }

        if (saturationValues.length === 0) {
            console.error("No valid saturation values calculated");
            return null;
        }

        let totalVariation = 0;
        for (let i = 1; i < saturationValues.length; i++) {
            totalVariation += Math.abs(saturationValues[i] - saturationValues[i - 1]);
        }

        return totalVariation;
    }

    // 6. LAB Length
    function calculate_lab_length(colormap, sampleCount = 9) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            console.error("Invalid colors array:", colors);
            return 0;
        }

        const samples = [];
        const step = (colors.length - 1) / (sampleCount - 1);

        for (let i = 0; i < sampleCount; i++) {
            const index = Math.min(Math.floor(i * step), colors.length - 1);
            try {
                const r = parseInt(colors[index].rgb[0]);
                const g = parseInt(colors[index].rgb[1]);
                const b = parseInt(colors[index].rgb[2]);

                if (isNaN(r) || isNaN(g) || isNaN(b)) {
                    console.error(`Invalid rgb values for sampled color ${i}:`, colors[index].rgb);
                    continue;
                }

                const rgbColor = d3.rgb(r, g, b);
                const lab = d3.lab(rgbColor);

                const lValue = lab.l !== undefined ? lab.l : lab.L;
                if (!isNaN(lValue) && !isNaN(lab.a) && !isNaN(lab.b)) {
                    samples.push(lab);
                }
            } catch (error) {
                console.error(`Error sampling color ${i}:`, error);
            }
        }

        if (samples.length < 2) {
            console.error("Not enough valid samples for LAB length calculation");
            return 0;
        }

        let totalLabLength = 0;

        for (let i = 0; i < samples.length - 1; i++) {
            const lab1 = samples[i];
            const lab2 = samples[i + 1];

            const l1 = lab1.l !== undefined ? lab1.l : lab1.L;
            const l2 = lab2.l !== undefined ? lab2.l : lab2.L;

            const distance = Math.sqrt(
                Math.pow(l2 - l1, 2) +
                Math.pow(lab2.a - lab1.a, 2) +
                Math.pow(lab2.b - lab1.b, 2)
            );

            if (isNaN(distance)) {
                console.warn(`LAB distance is NaN for samples ${i}-${i + 1}`);
            }

            totalLabLength += distance;
        }

        return totalLabLength;
    }

    // ========== Color Naming Functions ==========

    function getColorNameIndex(c) {
        if (typeof c3 === 'undefined' || !c3.color) {
            return 0;
        }

        var x = d3.lab(c);
        var minDist = Number.MAX_VALUE;
        var minIndex = 0;

        var xL = x.l !== undefined ? x.l : x.L;
        var xA = x.a;
        var xB = x.b;

        for (var i = 0; i < c3.color.length; i++) {
            var c2 = c3.color[i];
            var c2L = c2.l !== undefined ? c2.l : c2.L;
            var c2A = c2.a;
            var c2B = c2.b;

            var dist = Math.sqrt(
                Math.pow(xL - c2L, 2) +
                Math.pow(xA - c2A, 2) +
                Math.pow(xB - c2B, 2)
            );

            if (dist < minDist) {
                minDist = dist;
                minIndex = i;
            }
        }

        return minIndex;
    }

    function getNameDifference(c0, c1) {
        if (typeof c3 === 'undefined' || !c3.color) {
            var lab0 = d3.lab(c0);
            var lab1 = d3.lab(c1);
            var lVal0 = lab0.l !== undefined ? lab0.l : lab0.L;
            var lVal1 = lab1.l !== undefined ? lab1.l : lab1.L;
            return Math.sqrt(
                Math.pow(lVal1 - lVal0, 2) +
                Math.pow(lab1.a - lab0.a, 2) +
                Math.pow(lab1.b - lab0.b, 2)
            ) / 100;
        }

        var i0 = getColorNameIndex(c0);
        var i1 = getColorNameIndex(c1);

        if (i0 === i1) {
            return 0;
        }

        try {
            var hellinger = c3.color.hellinger(i0, i1);
            return hellinger;
        } catch (e) {
            return 0;
        }
    }

    function nameSalience(c) {
        if (typeof c3 === 'undefined' || !c3.color) {
            return 0;
        }

        var minE = -4.5;
        var maxE = 0.0;
        var i = getColorNameIndex(c);
        var ent = c3.color.entropy(i);
        return (ent - minE) / (maxE - minE);
    }

    // 7. Color Name Variation
    function calculate_color_name_variation(colormap, sampleCount = 9) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            return 0;
        }

        const samples = [];
        const step = (colors.length - 1) / (sampleCount - 1);

        for (let i = 0; i < sampleCount; i++) {
            const index = Math.min(Math.floor(i * step), colors.length - 1);
            try {
                const r = parseInt(colors[index].rgb[0]);
                const g = parseInt(colors[index].rgb[1]);
                const b = parseInt(colors[index].rgb[2]);

                if (isNaN(r) || isNaN(g) || isNaN(b)) {
                    continue;
                }

                samples.push(d3.rgb(r, g, b));
            } catch (error) {
                // Skip errors
            }
        }

        let totalNameDifference = 0;
        let validPairs = 0;

        for (let i = 0; i < samples.length - 1; i++) {
            try {
                const c0 = samples[i];
                const c1 = samples[i + 1];
                if (c0 && c1 && typeof getNameDifference === 'function') {
                    const nameDiff = getNameDifference(c0, c1);

                    if (!isNaN(nameDiff) && isFinite(nameDiff)) {
                        totalNameDifference += nameDiff;
                        validPairs++;
                    }
                }
            } catch (error) {
                // Skip errors
            }
        }

        return validPairs > 0 ? totalNameDifference : 0;
    }

    // ========== Color Categorization Tendency ==========

    function agglomerativeClusteringByName(colors, dissimilarityThreshold = 0.6) {
        if (!colors || colors.length === 0) {
            return [];
        }

        let clusters = colors.map((color, i) => ({
            id: i,
            colors: [color]
        }));

        let merged = true;
        while (merged && clusters.length > 1) {
            merged = false;

            let minDissimilarity = Infinity;
            let mergeIndex = -1;

            for (let i = 0; i < clusters.length - 1; i++) {
                const c1 = clusters[i];
                const c2 = clusters[i + 1];

                let totalDissim = 0;
                let pairCount = 0;

                for (let color1 of c1.colors) {
                    for (let color2 of c2.colors) {
                        const dissim = getNameDifference(color1, color2);
                        if (!isNaN(dissim) && isFinite(dissim)) {
                            totalDissim += dissim;
                            pairCount++;
                        }
                    }
                }

                const avgDissim = pairCount > 0 ? totalDissim / pairCount : Infinity;

                if (avgDissim < minDissimilarity) {
                    minDissimilarity = avgDissim;
                    mergeIndex = i;
                }
            }

            if (mergeIndex >= 0 && minDissimilarity < dissimilarityThreshold) {
                const c1 = clusters[mergeIndex];
                const c2 = clusters[mergeIndex + 1];

                const mergedCluster = {
                    id: c1.id,
                    colors: [...c1.colors, ...c2.colors]
                };

                clusters.splice(mergeIndex, 2, mergedCluster);
                merged = true;
            }
        }

        return clusters;
    }

    function selectClusterCentroid(cluster) {
        if (!cluster || !cluster.colors || cluster.colors.length === 0) {
            return null;
        }

        if (typeof nameSalience !== 'function') {
            return cluster.colors[0];
        }

        let maxSaliency = -Infinity;
        let centroid = cluster.colors[0];

        for (let color of cluster.colors) {
            try {
                const saliency = nameSalience(color);
                if (!isNaN(saliency) && saliency > maxSaliency) {
                    maxSaliency = saliency;
                    centroid = color;
                }
            } catch (e) {
                // Skip errors
            }
        }

        return centroid;
    }

    // 8. Color Categorization Tendency
    function calculate_color_categorization_tendency(colormap, sampleCount = 100, dissimilarityThreshold = 0.6) {
        const colors = convertColormapToStandardFormat(colormap);
        if (!colors || !colors.length) {
            return 0;
        }

        const samples = [];
        const step = Math.max(1, Math.floor(colors.length / sampleCount));

        for (let i = 0; i < colors.length; i += step) {
            if (samples.length >= sampleCount) break;

            try {
                const r = parseInt(colors[i].rgb[0]);
                const g = parseInt(colors[i].rgb[1]);
                const b = parseInt(colors[i].rgb[2]);

                if (!isNaN(r) && !isNaN(g) && !isNaN(b)) {
                    samples.push(d3.rgb(r, g, b));
                }
            } catch (error) {
                // Skip errors
            }
        }

        if (samples.length < 2) {
            return 0;
        }

        // OPTIMIZATION: Pre-compute distance matrix
        const distMatrix = new Array(samples.length);
        for (let i = 0; i < samples.length; i++) {
            distMatrix[i] = new Array(samples.length);
            for (let j = 0; j < samples.length; j++) {
                if (i === j) {
                    distMatrix[i][j] = 0;
                } else if (j > i) {
                    distMatrix[i][j] = getNameDifference(samples[i], samples[j]);
                } else {
                    distMatrix[i][j] = distMatrix[j][i];
                }
            }
        }

        const clusters = agglomerativeClusteringOptimized(samples, distMatrix, dissimilarityThreshold);
        const K = clusters.length;

        if (K < 2) {
            return 0;
        }

        const centroids = [];
        for (let cluster of clusters) {
            const clusterColors = cluster.indices.map(idx => samples[idx]);
            const centroid = selectClusterCentroid({ colors: clusterColors });
            if (centroid) {
                centroids.push(centroid);
            }
        }

        if (centroids.length < 2) {
            return 0;
        }

        let totalDeltaE = 0;
        let pairCount = 0;

        for (let i = 0; i < centroids.length; i++) {
            for (let j = i + 1; j < centroids.length; j++) {
                const lab1 = d3.lab(centroids[i]);
                const lab2 = d3.lab(centroids[j]);

                const l1 = lab1.l !== undefined ? lab1.l : lab1.L;
                const l2 = lab2.l !== undefined ? lab2.l : lab2.L;

                const deltaE = ciede2000([l1, lab1.a, lab1.b], [l2, lab2.a, lab2.b]);

                if (!isNaN(deltaE) && isFinite(deltaE)) {
                    totalDeltaE += deltaE;
                    pairCount++;
                }
            }
        }

        const meanDeltaE = pairCount > 0 ? totalDeltaE / pairCount : 0;
        return K * meanDeltaE;
    }

    // Optimized clustering with pre-computed distance matrix
    function agglomerativeClusteringOptimized(samples, distMatrix, dissimilarityThreshold = 0.6) {
        if (!samples || samples.length === 0) {
            return [];
        }

        let clusters = samples.map((_, i) => ({
            id: i,
            indices: [i]
        }));

        let merged = true;
        
        while (merged && clusters.length > 1) {
            merged = false;
            
            let minDissimilarity = Infinity;
            let mergeIndex = -1;
            
            for (let i = 0; i < clusters.length - 1; i++) {
                const c1 = clusters[i];
                const c2 = clusters[i + 1];
                
                let totalDissim = 0;
                let pairCount = 0;
                
                for (let idx1 of c1.indices) {
                    for (let idx2 of c2.indices) {
                        const dissim = distMatrix[idx1][idx2];
                        if (!isNaN(dissim) && isFinite(dissim)) {
                            totalDissim += dissim;
                            pairCount++;
                        }
                    }
                }
                
                const avgDissim = pairCount > 0 ? totalDissim / pairCount : Infinity;
                
                if (avgDissim < minDissimilarity) {
                    minDissimilarity = avgDissim;
                    mergeIndex = i;
                }
            }
            
            if (mergeIndex >= 0 && minDissimilarity < dissimilarityThreshold) {
                const c1 = clusters[mergeIndex];
                const c2 = clusters[mergeIndex + 1];
                
                const mergedCluster = {
                    id: c1.id,
                    indices: [...c1.indices, ...c2.indices]
                };
                
                clusters.splice(mergeIndex, 2, mergedCluster);
                merged = true;
            }
        }
        
        return clusters;
    }

    // 计算所有 metrics 并显示
    function calculateAndDisplayMetrics(colormap, title = "Colormap Metrics") {
        console.log(`\n========== ${title} ==========`);

        try {
            const metrics = {};

            metrics.discriminatory_cie = discriminatory_cie(colormap) || 0;
            console.log('CIEDE2000 Discriminative Power:', metrics.discriminatory_cie.toFixed(3));

            metrics.discriminatory_contrast = discriminatory_contrast_sensitivity(colormap) || 0;
            console.log('Contrast Sensitivity:', metrics.discriminatory_contrast.toFixed(3));

            metrics.discriminatory_hue = discriminatory_hue(colormap) || 0;
            console.log('Hue Discriminative Power:', metrics.discriminatory_hue.toFixed(3));

            metrics.luminance_var = luminance_variation(colormap) || 0;
            console.log('Luminance Variation:', metrics.luminance_var.toFixed(3));

            metrics.chromatic_var = chromatic_variation(colormap) || 0;
            console.log('Chromatic Variation:', metrics.chromatic_var.toFixed(3));

            metrics.lab_length = calculate_lab_length(colormap) || 0;
            console.log('LAB Length:', metrics.lab_length.toFixed(3));

            metrics.color_name_var = calculate_color_name_variation(colormap) || 0;

                metrics.categorization_tendency = calculate_color_categorization_tendency(colormap) || 0;
                console.log('Color Categorization Tendency:', metrics.categorization_tendency.toFixed(3));

                // Convert colormap to HCL format for calcSmoothnessMinDiff
                const hclPalette = colormap.map(color => {
                    const lab = d3.lab(color);
                    const hcl = d3.hcl(lab);
                    return [hcl.h, hcl.c, hcl.l];
                });
                metrics.smoothness_min_diff = calcSmoothnessMinDiff(hclPalette) || 0;
                console.log('Min Color Diff:', metrics.smoothness_min_diff.toFixed(3));
                
                // Calculate condition 2: sample interval min diff
                metrics.sample_interval_min_diff = calcSampleIntervalMinDiff(hclPalette, SAMPLE_INTERVAL_K) || 0;
                console.log(`Sample Interval Min Diff (k=${SAMPLE_INTERVAL_K}):`, metrics.sample_interval_min_diff.toFixed(3));

                console.log('==========================================\n');

                return metrics;
            } catch (error) {
                console.error('Error calculating metrics:', error);
                console.error('Error stack:', error.stack);
                return null;
            }
        }

        // 在 div 中显示 metrics（表格布局）
        function displayMetricsInDiv(div, metrics) {
            const metricsDiv = div.append("div")
                .style("margin-top", "0")
                .style("padding", "8px")
                .style("background", "white")
                .style("border", "1px solid #ddd")
                .style("border-radius", "4px");

            metricsDiv.append("h4")
                .text("📊 Metrics")
                .style("margin", "0 0 6px 0")
                .style("color", "#333")
                .style("font-size", "12px")
                .style("border-bottom", "1px solid #4CAF50")
                .style("padding-bottom", "3px");

            // 创建一个表格布局
            const table = metricsDiv.append("table")
                .style("width", "100%")
                .style("border-collapse", "collapse")
                .style("font-size", "11px");

            const metricsData = [
                { name: "Min Color Diff (C1)", value: metrics.smoothness_min_diff, color: "#795548" },
                { name: "Interval Diff (C2)", value: metrics.sample_interval_min_diff, color: "#00897B" },
                { name: "Hue", value: metrics.discriminatory_hue, color: "#9C27B0" },
                { name: "Chroma Var", value: metrics.chromatic_var, color: "#F44336" },
                { name: "Lumi Var", value: metrics.luminance_var, color: "#4CAF50" },
                { name: "CIEDE", value: metrics.discriminatory_cie, color: "#2196F3" },
                { name: "Contrast", value: metrics.discriminatory_contrast, color: "#FF9800" },
                { name: "LAB Len", value: metrics.lab_length, color: "#607D8B" },
                { name: "CNV", value: metrics.color_name_var, color: "#00BCD4" },
                { name: "Cat. Tend", value: metrics.categorization_tendency, color: "#E91E63" }
            ];

            // 两列布局：每行显示两个指标
            for (let i = 0; i < metricsData.length; i += 2) {
                const row = table.append("tr")
                    .style("border-bottom", i < metricsData.length - 2 ? "1px solid #eee" : "none");

            // 第一个指标
            const metric1 = metricsData[i];
            row.append("td")
                .style("padding", "4px 6px")
                .style("font-weight", "500")
                .style("color", "#555")
                .style("width", "30%")
                .html(`<span style="color: ${metric1.color}; font-size: 12px;">●</span> ${metric1.name}`);
            
            row.append("td")
                .style("padding", "4px 6px")
                .style("text-align", "right")
                .style("font-weight", "bold")
                .style("color", metric1.color)
                .style("width", "20%")
                .text(metric1.value.toFixed(2));

            // 第二个指标（如果存在）
            if (i + 1 < metricsData.length) {
                const metric2 = metricsData[i + 1];
                row.append("td")
                    .style("padding", "4px 6px")
                    .style("font-weight", "500")
                    .style("color", "#555")
                    .style("width", "30%")
                    .style("padding-left", "10px")
                    .html(`<span style="color: ${metric2.color}; font-size: 12px;">●</span> ${metric2.name}`);
                
                row.append("td")
                    .style("padding", "4px 6px")
                    .style("text-align", "right")
                    .style("font-weight", "bold")
                    .style("color", metric2.color)
                    .style("width", "20%")
                    .text(metric2.value.toFixed(2));
            } else {
                // 如果是奇数个指标，填充空列
                row.append("td").attr("colspan", "2");
            }
        }
    }
</script>

</html>