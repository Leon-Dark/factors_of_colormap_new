<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experiment Data Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            background-color: #f8f9fa;
        }

        #sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
            z-index: 10;
        }

        #sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            background: #f1f3f5;
        }

        #sidebar-header h2 {
            margin: 0;
            font-size: 1.2rem;
            color: #343a40;
        }

        #refresh-btn {
            margin-top: 10px;
            width: 100%;
            padding: 8px;
            cursor: pointer;
            background: #228be6;
            color: white;
            border: none;
            border-radius: 4px;
        }

        #refresh-btn:hover {
            background: #1c7ed6;
        }

        #file-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .file-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f1f3f5;
            transition: background 0.2s;
            font-size: 0.9rem;
            color: #495057;
        }

        .file-item:hover {
            background-color: #f8f9fa;
        }

        .file-item.active {
            background-color: #e7f5ff;
            color: #1971c2;
            border-left: 4px solid #1971c2;
        }

        .file-date {
            font-size: 0.8rem;
            color: #adb5bd;
            margin-top: 4px;
        }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #content-header {
            padding: 20px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #current-filename {
            margin: 0;
            font-size: 1.5rem;
            color: #343a40;
        }

        #download-btn {
            padding: 8px 16px;
            background: #40c057;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9rem;
            display: none;
        }

        #download-btn:hover {
            background: #37b24d;
        }

        #table-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        th {
            background: #f8f9fa;
            position: sticky;
            top: 0;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #adb5bd;
        }

        /* Chart Controls */
        .view-controls {
            display: flex;
            gap: 10px;
            margin-right: 20px;
        }

        .view-btn {
            padding: 6px 12px;
            border: 1px solid #dee2e6;
            background: #fff;
            cursor: pointer;
            border-radius: 4px;
        }

        .view-btn.active {
            background: #e7f5ff;
            border-color: #1971c2;
            color: #1971c2;
        }

        #chart-container {
            flex: 1;
            padding: 20px;
            position: relative;
            display: none;
            overflow-x: auto;
            /* Enable horizontal scrolling */
            /* Hidden by default */
        }

        /* Ensure canvas inside can force width */
        #chart-canvas-wrapper {
            min-width: 100%;
            /* Fallback */
            height: 100%;
        }

        #sidebar-analysis {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            background: #e9ecef;
        }

        #aggregate-btn {
            width: 100%;
            padding: 10px;
            background: #7950f2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #aggregate-btn:hover {
            background: #6741d9;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>

    <div id="sidebar">
        <div id="sidebar-header">
            <h2 id="files-header-title">Data Files</h2>
            <button id="refresh-btn">Refresh List</button>
        </div>
        <div id="sidebar-analysis">
            <button id="aggregate-btn">üìä Aggregate All Data</button>
        </div>
        <ul id="file-list">
            <!-- Items will be injected here -->
        </ul>
    </div>

    <div id="main-content">
        <div id="content-header">
            <div style="display:flex; align-items:center;">
                <h2 id="current-filename" style="margin-right:20px; margin-bottom:0;">Select a file</h2>
                <div id="engagement-stats" style="font-weight: bold; color: #555;"></div>
            </div>

            <div class="view-controls">
                <div style="margin-right: 15px; display: flex; align-items: center; gap: 8px;">
                    <label style="font-weight: bold;">Metric:</label>
                    <select id="metricSelect" onchange="toggleMetric()" style="padding: 4px; border-radius: 4px;">
                        <option value="accuracy">Accuracy</option>
                        <option value="time">Response Time</option>
                    </select>
                </div>

                <div style="margin-right: 15px; display: flex; align-items: center; gap: 8px;">
                    <label style="font-weight: bold;">X-Axis Factor:</label>
                    <select id="groupSelect" onchange="toggleGroup()" style="padding: 4px; border-radius: 4px;">
                        <option value="colormap">Individual Colormap</option>
                        <option value="hue">Hue</option>
                        <option value="chroma">Chroma Pattern</option>
                        <option value="luma">Luminance Pattern</option>
                    </select>
                </div>

                <div style="border-left: 1px solid #ccc; height: 20px; margin-right: 15px;"></div>

                <label style="display: flex; align-items: center; gap: 5px; margin-right: 15px; cursor: pointer;">
                    <input type="checkbox" id="filter-ssim-diff" onchange="toggleSSIMFilter(this.checked)">
                    <span style="font-size: 0.9rem;">Filter SSIM Œî > 0.0005</span>
                </label>

                <div style="border-left: 1px solid #ccc; height: 20px; margin-right: 15px;"></div>
                <button class="view-btn active" onclick="switchView('table')">Table</button>
                <button class="view-btn" onclick="switchView('bar')">Chart</button>
            </div>

            <a href="#" id="download-btn" download>Download CSV</a>
        </div>
        <div id="table-container">
            <div class="empty-state">
                <p>Select a file from the sidebar to view data</p>
            </div>
        </div>
        <div id="chart-container">
            <div id="chart-canvas-wrapper">
                <canvas id="dataChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        const fileListEl = document.getElementById('file-list');
        const refreshBtn = document.getElementById('refresh-btn');
        const aggregateBtn = document.getElementById('aggregate-btn');
        const tableContainer = document.getElementById('table-container');
        const chartContainer = document.getElementById('chart-container');
        const currentFilenameEl = document.getElementById('current-filename');
        const downloadBtn = document.getElementById('download-btn');

        let currentData = [];
        let myChart = null;
        let currentChartType = 'bar';
        let currentMetric = 'accuracy'; // 'accuracy' or 'time'
        let currentGroup = 'colormap'; // 'colormap', 'hue', 'chroma', 'luma'
        let filterSSIMDiff = false; // Filter out rows with |targetSSIM - actualSSIM| > 0.0005

        // Configuration
        // backendURL: The address where server.py is running.
        // For server deployment (same origin), leave this empty.
        // Relative paths will automatically correctly resolve to the server's IP/domain.
        const backendURL = '';

        // --- Functions ---

        function toggleMetric() {
            const sel = document.getElementById('metricSelect');
            currentMetric = sel.value;
            if (currentChartType !== 'table') {
                renderChart(currentData, currentChartType);
            }
        }

        function toggleGroup() {
            const sel = document.getElementById('groupSelect');
            currentGroup = sel.value;
            if (currentChartType !== 'table') {
                renderChart(currentData, currentChartType);
            }
        }

        // ...




        async function fetchFileList() {
            try {
                const response = await fetch(`${backendURL}/api/list_data`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const files = await response.json();

                // Sort by name (timestamp usually) descending
                files.sort().reverse();

                // Prefetch data to check engagement status
                // Limit to recent 50 to avoid network storm if huge folder, or just fetch all logic
                const validations = await validateFiles(files);

                // Count valid
                let validCount = 0;
                files.forEach(f => {
                    if (validations[f] && validations[f].passed) validCount++;
                });

                // Update header
                const filesHeaderTitle = document.getElementById('files-header-title');
                if (filesHeaderTitle) {
                    filesHeaderTitle.innerHTML = `Data Files <span style="font-size:0.8em; font-weight:normal; color:#555;">(${validCount} available)</span>`;
                }

                renderFileList(files, validations);
            } catch (error) {
                console.error('Error fetching file list:', error);
                fileListEl.innerHTML = '<li style="padding:20px; color:red">Error loading files. Is server.py running?</li>';
            }
        }

        async function validateFiles(files) {
            const results = {};
            const promises = files.map(async file => {
                try {
                    const res = await fetch(`${backendURL}/api/get_data/${file}`);
                    const txt = await res.text();
                    const rows = parseCSV(txt);
                    // Check engagement
                    // We need to re-parse logic briefly or extract it
                    // Finding headers
                    if (rows.length < 2) return;
                    const h = rows[0];
                    const idxSSIM = h.indexOf('targetSSIM');
                    const idxCorrect = h.indexOf('isCorrect');

                    if (idxSSIM === -1 || idxCorrect === -1) return;

                    let total = 0;
                    let correct = 0;

                    for (let i = 1; i < rows.length; i++) {
                        const r = rows[i];
                        const ssim = r[idxSSIM];
                        // Check for ~0.95 or 0.90
                        const val = parseFloat(ssim);
                        if (Math.abs(val - 0.80) < 0.001 || Math.abs(val - 0.90) < 0.0005) {
                            total++;
                            if (parseInt(r[idxCorrect]) === 1) correct++;
                        }
                    }

                    if (total > 0 && correct < total) {
                        results[file] = { passed: false, score: `${correct}/${total}` };
                    } else {
                        results[file] = { passed: true };
                    }

                } catch (e) { console.error(e); }
            });
            await Promise.all(promises);
            return results;
        }

        function renderFileList(files, validations = {}) {
            fileListEl.innerHTML = '';
            files.forEach(file => {
                const li = document.createElement('li');
                li.className = 'file-item';

                // Parse timestamp from filename if possible: id_timestamp.csv
                let dateStr = '';
                const parts = file.split('_');
                if (parts.length > 1) {
                    const ts = parseInt(parts[parts.length - 1].split('.')[0]);
                    if (!isNaN(ts)) {
                        dateStr = new Date(ts * 1000).toLocaleString();
                    }
                }

                const val = validations[file];
                let warnings = '';
                if (val && !val.passed) {
                    li.style.color = '#e03131';
                    li.style.background = '#fff5f5';
                    warnings = ` <span style="font-weight:bold; font-size:0.8em; border:1px solid red; border-radius:3px; padding:1px 3px;">‚ö†Ô∏è ${val.score}</span>`;
                }

                li.innerHTML = `
                    <div>${file}${warnings}</div>
                    ${dateStr ? `<div class="file-date">${dateStr}</div>` : ''}
                `;
                li.onclick = () => loadFile(file, li);
                fileListEl.appendChild(li);
            });
        }

        async function loadFile(filename, liElement) {
            // Update UI active state
            document.querySelectorAll('.file-item').forEach(el => el.classList.remove('active'));
            if (liElement) liElement.classList.add('active');

            currentFilenameEl.textContent = filename;
            tableContainer.innerHTML = '<p style="padding:20px">Loading...</p>';

            // Setup download link
            downloadBtn.href = `${backendURL}/api/get_data/${filename}`;
            downloadBtn.style.display = 'block';

            try {
                const response = await fetch(`${backendURL}/api/get_data/${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csvText = await response.text();
                processAndRender(csvText);
            } catch (e) {
                tableContainer.innerHTML = `<p style="color:red">Error loading file: ${e}</p>`;
            }
        }

        async function loadAllData() {
            // Update UI
            document.querySelectorAll('.file-item').forEach(el => el.classList.remove('active'));
            currentFilenameEl.textContent = "Aggregate Data (All Files)";
            tableContainer.innerHTML = '<p style="padding:20px">Loading all files...</p>';
            downloadBtn.style.display = 'none';

            try {
                // 1. Get List
                const listResp = await fetch(`${backendURL}/api/list_data`);
                const files = await listResp.json();

                if (files.length === 0) {
                    tableContainer.innerHTML = '<p>No data files found.</p>';
                    return;
                }

                // 2. Fetch All (Parallel)
                const promises = files.map(f => fetch(`${backendURL}/api/get_data/${f}`).then(r => r.text()));
                const allCsvs = await Promise.all(promises);

                // 3. Combine
                let combinedRows = [];
                // Keep header from first, skip others
                // Actually easier to just parse each and concat objects

                allCsvs.forEach((csv, idx) => {
                    const rows = parseCSV(csv);
                    if (idx === 0) {
                        combinedRows = rows;
                    } else {
                        // Skip header
                        combinedRows = combinedRows.concat(rows.slice(1));
                    }
                });

                // Render
                currentData = combinedRows;
                renderTableFromData(currentData);
                renderChart(currentData, currentChartType);

                // Auto switch to chart view for aggregate
                if (currentChartType === 'table') {
                    switchView('bar'); // Default to bar for aggregate if currently table
                } else {
                    switchView(currentChartType);
                }

            } catch (e) {
                console.error(e);
                tableContainer.innerHTML = `<p style="color:red">Error loading aggregate data: ${e}</p>`;
            }
        }

        function processAndRender(csvText) {
            currentData = parseCSV(csvText);
            renderTableFromData(currentData);
            renderChart(currentData, currentChartType);
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return [];

            // We need to handle quotes nicely, so use regex or a simple parser
            // Reusing existing simple parser logic but returning array of lines (arrays)
            return lines.map(line => parseCSVRow(line));
        }

        function renderTableFromData(data) {
            if (!data || data.length === 0) {
                tableContainer.innerHTML = '<p>Empty data</p>';
                return;
            }

            const headers = data[0];
            let rows = data.slice(1);

            // Apply SSIM difference filter if enabled
            if (filterSSIMDiff) {
                const idxTargetSSIM = headers.indexOf('targetSSIM');
                const idxActualSSIM = headers.indexOf('actualSSIM');

                if (idxTargetSSIM !== -1 && idxActualSSIM !== -1) {
                    rows = rows.filter(row => {
                        const target = parseFloat(row[idxTargetSSIM]);
                        const actual = parseFloat(row[idxActualSSIM]);
                        return Math.abs(target - actual) <= 0.0005;
                    });
                }
            }

            const table = document.createElement('table');

            // Header
            const thead = document.createElement('thead');
            const trHead = document.createElement('tr');
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                trHead.appendChild(th);
            });
            thead.appendChild(trHead);
            table.appendChild(thead);

            // Body
            const tbody = document.createElement('tbody');
            // Limit to showing 500 rows to prevent crash on aggregate
            const maxRows = 500;
            const limit = Math.min(rows.length, maxRows);

            for (let i = 0; i < limit; i++) {
                const tr = document.createElement('tr');
                const cols = rows[i];
                cols.forEach(c => {
                    const td = document.createElement('td');
                    td.textContent = c;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            }
            if (rows.length > maxRows) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = headers.length;
                td.textContent = `... and ${rows.length - maxRows} more rows ...`;
                td.style.textAlign = "center";
                td.style.color = "#888";
                tr.appendChild(td);
                tbody.appendChild(tr);
            }

            table.appendChild(tbody);
            tableContainer.innerHTML = '';
            tableContainer.appendChild(table);
        }


        function switchMetric(val) {
            currentMetric = val;
            if (currentChartType !== 'table') {
                renderChart(currentData, currentChartType);
            }
        }

        function toggleSSIMFilter(enabled) {
            filterSSIMDiff = enabled;
            if (currentChartType !== 'table') {
                renderChart(currentData, currentChartType);
            } else {
                renderTableFromData(currentData);
            }
        }

        // --- Visualization Logic ---

        function renderChart(data, type) {
            console.log("renderChart called. Group:", currentGroup, "Data length:", data ? data.length : 0);
            if (!data || data.length < 2) return;

            const headers = data[0];
            let rows = data.slice(1);

            // Accessors
            const idxFreq = headers.indexOf('frequencyId');
            const idxColormap = headers.indexOf('colormapId') !== -1 ? headers.indexOf('colormapId') : headers.indexOf('colormap');

            // Descriptive columns for labels
            const idxHue = headers.indexOf('colormapHue');
            const idxChroma = headers.indexOf('colormapChromaPattern');
            const idxLuma = headers.indexOf('colormapLumaPattern');

            const idxCorrect = headers.indexOf('isCorrect');
            let idxRT = headers.indexOf('reactionTimeMs');
            if (idxRT === -1) idxRT = headers.indexOf('responseTime');
            if (idxRT === -1) idxRT = headers.indexOf('rt');
            if (idxRT === -1) idxRT = headers.indexOf('time');

            // Handle Engagement Checks (Filter them OUT)
            const idxSSIM = headers.indexOf('targetSSIM');

            if (idxFreq === -1 || idxCorrect === -1 || idxColormap === -1) {
                console.warn("Missing necessary columns for visualization (need frequencyId, isCorrect, and colormapId/colormap)");
                if (idxColormap === -1) {
                    alert("Data does not contain 'colormapId' column. Cannot render Colormap breakdown.");
                    return;
                }
            }

            // --- Aggregation ---
            // Structure: stats[groupKey][frequency] = { correct, total, rtSum }
            const stats = {};
            const idToLabel = {}; // Map GroupKey to Description

            let experimentCorrect = 0;
            let experimentTotal = 0;

            rows.forEach(row => {
                const freq = row[idxFreq];
                const colormap = row[idxColormap];
                const correct = parseInt(row[idxCorrect]);
                const rt = idxRT !== -1 ? parseFloat(row[idxRT]) : 0;
                const ssim = idxSSIM !== -1 ? parseFloat(row[idxSSIM]) : 0;

                // Get Factor Values
                const h = idxHue !== -1 ? row[idxHue] : '?';
                const c = idxChroma !== -1 ? row[idxChroma] : '?';
                const l = idxLuma !== -1 ? row[idxLuma] : '?';

                // Engagement Check Filter - skip these for chart but don't count them
                if (Math.abs(ssim - 0.80) < 0.001 || Math.abs(ssim - 0.90) < 0.001) {
                    // Do NOT include engagement checks in the main chart or experiment stats
                    return;
                }

                // Count experiment trials (non-engagement)
                experimentTotal++;
                if (correct === 1) experimentCorrect++;

                // Determine Group Key based on currentGroup
                let groupKey = colormap;
                let groupLabel = `H=${h}, C=${c}, L=${l}`;

                if (currentGroup === 'hue') {
                    groupKey = h;
                    groupLabel = `Hue=${h}`;
                } else if (currentGroup === 'chroma') {
                    groupKey = c;
                    groupLabel = `Chroma=${c}`;
                } else if (currentGroup === 'luma') {
                    groupKey = l;
                    groupLabel = `Luma=${l}`;
                }

                // Initialize Stats Entry
                if (!stats[groupKey]) {
                    stats[groupKey] = {};
                    idToLabel[groupKey] = groupLabel;
                }
                if (!stats[groupKey][freq]) stats[groupKey][freq] = { correct: 0, total: 0, rtSum: 0 };

                stats[groupKey][freq].correct += (correct === 1 ? 1 : 0);
                stats[groupKey][freq].rtSum += (!isNaN(rt) ? rt : 0);
                stats[groupKey][freq].total += 1;
            });

            // Update Experiment Stats UI (non-engagement trials)
            const engStatsEl = document.getElementById('engagement-stats');
            if (experimentTotal > 0) {
                const expAcc = (experimentCorrect / experimentTotal * 100).toFixed(1);
                engStatsEl.textContent = `Experiment Accuracy: ${expAcc}% (${experimentCorrect}/${experimentTotal})`;
                engStatsEl.style.color = (expAcc >= 50) ? '#2b8a3e' : '#e03131';
            } else {
                engStatsEl.textContent = '';
            }

            // --- Chart Data Preparation ---
            // Sort Keys
            let sortedKeys = Object.keys(stats);
            console.log("Generated stats keys:", sortedKeys);

            sortedKeys.sort((a, b) => {
                if (currentGroup === 'hue') {
                    // Numerical sort for Hue
                    const numA = parseFloat(a);
                    const numB = parseFloat(b);
                    if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
                }
                // Default lexical sort
                return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
            });

            // Set Canvas Container Width for Scrolling
            // Assume ~80px per item
            const itemWidth = 80;
            const requiredWidth = Math.max(100, sortedKeys.length * itemWidth);
            const wrapper = document.getElementById('chart-canvas-wrapper');
            if (wrapper) {
                wrapper.style.width = `${requiredWidth}px`;
                wrapper.style.height = '100%';
            }

            // Generate descriptive labels
            const labels = sortedKeys.map(key => idToLabel[key] || key);

            const frequencies = ['low', 'medium', 'high'];
            const colors = {
                'low': 'rgba(255, 127, 0)',   // Orange
                'medium': 'rgba(77, 175, 74)', // Green
                'high': 'rgba(55, 126, 184)'   // Blue
            };

            const datasets = frequencies.map(freq => {
                const dataPoints = sortedKeys.map(key => {
                    const item = stats[key][freq];
                    if (!item || item.total === 0) return 0;

                    if (currentMetric === 'accuracy') {
                        return (item.correct / item.total);
                    } else {
                        return (item.rtSum / item.total);
                    }
                });

                const baseColor = colors[freq] || 'rgba(200, 200, 200)';

                return {
                    label: freq.toUpperCase() + ' Freq',
                    data: dataPoints,
                    backgroundColor: baseColor.replace(')', ', 0.7)'),
                    borderColor: baseColor,
                    borderWidth: 1,
                    // Line chart specific
                    tension: 0.1,
                    fill: false,
                    pointRadius: 4
                };
            });

            // Add 62.5% Threshold Line (Only for Accuracy)
            if (currentMetric === 'accuracy') {
                const thresholdValue = 0.625;
                datasets.push({
                    type: 'line',
                    label: '62.5% Threshold',
                    data: Array(sortedKeys.length).fill(thresholdValue),
                    borderColor: 'rgba(0, 0, 0, 0.6)',
                    borderWidth: 2,
                    borderDash: [8, 8],
                    pointRadius: 0,
                    fill: false,
                    order: 0
                });
            }

            // Create/Update Chart
            const ctx = document.getElementById('dataChart').getContext('2d');

            if (myChart) {
                myChart.destroy();
            }

            // Dynamically set X-Axis Title
            let xAxisTitle = 'Colormap Parameters';
            if (currentGroup === 'hue') xAxisTitle = 'Hue (Degrees)';
            else if (currentGroup === 'chroma') xAxisTitle = 'Chroma Type';
            else if (currentGroup === 'luma') xAxisTitle = 'Luminance Type';

            myChart = new Chart(ctx, {
                type: type === 'line' ? 'line' : 'bar', // Helper to keep it valid
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: currentMetric === 'accuracy' ? 1.0 : undefined,
                            title: {
                                display: true,
                                text: currentMetric === 'accuracy' ? 'Accuracy' : 'Avg Response Time (ms)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: xAxisTitle
                            },
                            ticks: {
                                maxRotation: 90,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: currentMetric === 'accuracy' ? 'Accuracy by ' + currentGroup.charAt(0).toUpperCase() + currentGroup.slice(1) + ' & Frequency'
                                : 'Response Time by ' + currentGroup.charAt(0).toUpperCase() + currentGroup.slice(1) + ' & Frequency'
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    if (currentMetric === 'accuracy') {
                                        return context.dataset.label + ': ' + (context.raw * 100).toFixed(1) + '%';
                                    } else {
                                        return context.dataset.label + ': ' + context.raw.toFixed(0) + ' ms';
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        function switchView(viewName) {
            // Update buttons
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            // Find the button for this view
            const btn = document.querySelector(`button[onclick="switchView('${viewName}')"]`);
            if (btn) btn.classList.add('active');

            if (viewName === 'table') {
                tableContainer.style.display = 'block';
                chartContainer.style.display = 'none';
                currentChartType = 'table';
            } else {
                // 'bar' or 'line'
                tableContainer.style.display = 'none';
                chartContainer.style.display = 'block';

                if (currentChartType !== viewName || !myChart) {
                    currentChartType = viewName;
                    renderChart(currentData, viewName);
                }
            }
        }

        // --- Utils ---

        // Simple CSV parser that handles quotes
        function parseCSVRow(row) {
            const result = [];
            let current = '';
            let inQuote = false;

            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                if (char === '"') {
                    inQuote = !inQuote;
                } else if (char === ',' && !inQuote) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result.map(s => s.replace(/^"|"$/g, '')); // Remove surrounding quotes
        }

        refreshBtn.onclick = fetchFileList;
        aggregateBtn.onclick = loadAllData;

        // Init
        fetchFileList();
    </script>
</body>

</html>