<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experiment Data Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            background-color: #f8f9fa;
        }

        #sidebar {
            width: 300px;
            background: white;
            border-right: 1px solid #dee2e6;
            display: flex;
            flex-direction: column;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
            z-index: 10;
        }

        #sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            background: #f1f3f5;
        }

        #sidebar-header h2 {
            margin: 0;
            font-size: 1.2rem;
            color: #343a40;
        }

        #refresh-btn {
            margin-top: 10px;
            width: 100%;
            padding: 8px;
            cursor: pointer;
            background: #228be6;
            color: white;
            border: none;
            border-radius: 4px;
        }

        #refresh-btn:hover {
            background: #1c7ed6;
        }

        #file-list {
            flex: 1;
            overflow-y: auto;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .file-item {
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid #f1f3f5;
            transition: background 0.2s;
            font-size: 0.9rem;
            color: #495057;
        }

        .file-item:hover {
            background-color: #f8f9fa;
        }

        .file-item.active {
            background-color: #e7f5ff;
            color: #1971c2;
            border-left: 4px solid #1971c2;
        }

        .file-date {
            font-size: 0.8rem;
            color: #adb5bd;
            margin-top: 4px;
        }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #content-header {
            padding: 20px;
            background: white;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #current-filename {
            margin: 0;
            font-size: 1.5rem;
            color: #343a40;
        }

        #download-btn {
            padding: 8px 16px;
            background: #40c057;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 0.9rem;
            display: none;
        }

        #download-btn:hover {
            background: #37b24d;
        }

        #table-container {
            flex: 1;
            overflow: auto;
            padding: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        th,
        td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        th {
            background: #f8f9fa;
            position: sticky;
            top: 0;
            font-weight: 600;
            color: #495057;
            border-bottom: 2px solid #dee2e6;
        }

        tr:hover {
            background: #f8f9fa;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #adb5bd;
        }

        /* Chart Controls */
        .view-controls {
            display: flex;
            gap: 10px;
            margin-right: 20px;
        }

        .view-btn {
            padding: 6px 12px;
            border: 1px solid #dee2e6;
            background: #fff;
            cursor: pointer;
            border-radius: 4px;
        }

        .view-btn.active {
            background: #e7f5ff;
            border-color: #1971c2;
            color: #1971c2;
        }

        #chart-container {
            flex: 1;
            padding: 20px;
            position: relative;
            display: none;
            /* Hidden by default */
        }

        #sidebar-analysis {
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
            background: #e9ecef;
        }

        #aggregate-btn {
            width: 100%;
            padding: 10px;
            background: #7950f2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        #aggregate-btn:hover {
            background: #6741d9;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>

    <div id="sidebar">
        <div id="sidebar-header">
            <h2 id="files-header-title">Data Files</h2>
            <button id="refresh-btn">Refresh List</button>
        </div>
        <div id="sidebar-analysis">
            <button id="aggregate-btn">üìä Aggregate All Data</button>
        </div>
        <ul id="file-list">
            <!-- Items will be injected here -->
        </ul>
    </div>

    <div id="main-content">
        <div id="content-header">
            <div style="display:flex; align-items:center;">
                <h2 id="current-filename" style="margin-right:20px; margin-bottom:0;">Select a file</h2>
                <div id="engagement-stats" style="font-weight: bold; color: #555;"></div>
            </div>

            <div class="view-controls">
                <div style="margin-right: 15px; display: flex; align-items: center; gap: 8px;">
                    <span>Metric:</span>
                    <label><input type="radio" name="metric" value="accuracy" checked
                            onchange="switchMetric(this.value)"> Accuracy</label>
                    <label><input type="radio" name="metric" value="time" onchange="switchMetric(this.value)">
                        Time</label>
                </div>
                <div style="border-left: 1px solid #ccc; height: 20px; margin-right: 15px;"></div>
                <button class="view-btn active" onclick="switchView('table')">Table</button>
                <button class="view-btn" onclick="switchView('bar')">Bar Chart</button>
                <button class="view-btn" onclick="switchView('line')">Line Chart</button>
            </div>

            <a href="#" id="download-btn" download>Download CSV</a>
        </div>
        <div id="table-container">
            <div class="empty-state">
                <p>Select a file from the sidebar to view data</p>
            </div>
        </div>
        <div id="chart-container">
            <canvas id="dataChart"></canvas>
        </div>
    </div>

    <script>
        const fileListEl = document.getElementById('file-list');
        const refreshBtn = document.getElementById('refresh-btn');
        const aggregateBtn = document.getElementById('aggregate-btn');
        const tableContainer = document.getElementById('table-container');
        const chartContainer = document.getElementById('chart-container');
        const currentFilenameEl = document.getElementById('current-filename');
        const downloadBtn = document.getElementById('download-btn');

        let currentData = [];
        let myChart = null;
        let currentChartType = 'bar';
        let currentMetric = 'accuracy'; // 'accuracy' or 'time'

        // Configuration
        // backendURL: The address where server.py is running.
        // For server deployment (same origin), leave this empty.
        // Relative paths will automatically correctly resolve to the server's IP/domain.
        const backendURL = '';

        // --- Functions ---

        async function fetchFileList() {
            try {
                const response = await fetch(`${backendURL}/api/list_data`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const files = await response.json();

                // Sort by name (timestamp usually) descending
                files.sort().reverse();

                // Prefetch data to check engagement status
                // Limit to recent 50 to avoid network storm if huge folder, or just fetch all logic
                const validations = await validateFiles(files);

                // Count valid
                let validCount = 0;
                files.forEach(f => {
                    if (validations[f] && validations[f].passed) validCount++;
                });

                // Update header
                const filesHeaderTitle = document.getElementById('files-header-title');
                if (filesHeaderTitle) {
                    filesHeaderTitle.innerHTML = `Data Files <span style="font-size:0.8em; font-weight:normal; color:#555;">(${validCount} available)</span>`;
                }

                renderFileList(files, validations);
            } catch (error) {
                console.error('Error fetching file list:', error);
                fileListEl.innerHTML = '<li style="padding:20px; color:red">Error loading files. Is server.py running?</li>';
            }
        }

        async function validateFiles(files) {
            const results = {};
            const promises = files.map(async file => {
                try {
                    const res = await fetch(`${backendURL}/api/get_data/${file}`);
                    const txt = await res.text();
                    const rows = parseCSV(txt);
                    // Check engagement
                    // We need to re-parse logic briefly or extract it
                    // Finding headers
                    if (rows.length < 2) return;
                    const h = rows[0];
                    const idxSSIM = h.indexOf('targetSSIM');
                    const idxCorrect = h.indexOf('isCorrect');

                    if (idxSSIM === -1 || idxCorrect === -1) return;

                    let total = 0;
                    let correct = 0;

                    for (let i = 1; i < rows.length; i++) {
                        const r = rows[i];
                        const ssim = r[idxSSIM];
                        // Check for ~0.95
                        if (Math.abs(parseFloat(ssim) - 0.95) < 0.0001) {
                            total++;
                            if (parseInt(r[idxCorrect]) === 1) correct++;
                        }
                    }

                    if (total > 0 && correct < total) {
                        results[file] = { passed: false, score: `${correct}/${total}` };
                    } else {
                        results[file] = { passed: true };
                    }

                } catch (e) { console.error(e); }
            });
            await Promise.all(promises);
            return results;
        }

        function renderFileList(files, validations = {}) {
            fileListEl.innerHTML = '';
            files.forEach(file => {
                const li = document.createElement('li');
                li.className = 'file-item';

                // Parse timestamp from filename if possible: id_timestamp.csv
                let dateStr = '';
                const parts = file.split('_');
                if (parts.length > 1) {
                    const ts = parseInt(parts[parts.length - 1].split('.')[0]);
                    if (!isNaN(ts)) {
                        dateStr = new Date(ts * 1000).toLocaleString();
                    }
                }

                const val = validations[file];
                let warnings = '';
                if (val && !val.passed) {
                    li.style.color = '#e03131';
                    li.style.background = '#fff5f5';
                    warnings = ` <span style="font-weight:bold; font-size:0.8em; border:1px solid red; border-radius:3px; padding:1px 3px;">‚ö†Ô∏è ${val.score}</span>`;
                }

                li.innerHTML = `
                    <div>${file}${warnings}</div>
                    ${dateStr ? `<div class="file-date">${dateStr}</div>` : ''}
                `;
                li.onclick = () => loadFile(file, li);
                fileListEl.appendChild(li);
            });
        }

        async function loadFile(filename, liElement) {
            // Update UI active state
            document.querySelectorAll('.file-item').forEach(el => el.classList.remove('active'));
            if (liElement) liElement.classList.add('active');

            currentFilenameEl.textContent = filename;
            tableContainer.innerHTML = '<p style="padding:20px">Loading...</p>';

            // Setup download link
            downloadBtn.href = `${backendURL}/api/get_data/${filename}`;
            downloadBtn.style.display = 'block';

            try {
                const response = await fetch(`${backendURL}/api/get_data/${filename}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csvText = await response.text();
                processAndRender(csvText);
            } catch (e) {
                tableContainer.innerHTML = `<p style="color:red">Error loading file: ${e}</p>`;
            }
        }

        async function loadAllData() {
            // Update UI
            document.querySelectorAll('.file-item').forEach(el => el.classList.remove('active'));
            currentFilenameEl.textContent = "Aggregate Data (All Files)";
            tableContainer.innerHTML = '<p style="padding:20px">Loading all files...</p>';
            downloadBtn.style.display = 'none';

            try {
                // 1. Get List
                const listResp = await fetch(`${backendURL}/api/list_data`);
                const files = await listResp.json();

                if (files.length === 0) {
                    tableContainer.innerHTML = '<p>No data files found.</p>';
                    return;
                }

                // 2. Fetch All (Parallel)
                const promises = files.map(f => fetch(`${backendURL}/api/get_data/${f}`).then(r => r.text()));
                const allCsvs = await Promise.all(promises);

                // 3. Combine
                let combinedRows = [];
                // Keep header from first, skip others
                // Actually easier to just parse each and concat objects

                allCsvs.forEach((csv, idx) => {
                    const rows = parseCSV(csv);
                    if (idx === 0) {
                        combinedRows = rows;
                    } else {
                        // Skip header
                        combinedRows = combinedRows.concat(rows.slice(1));
                    }
                });

                // Render
                currentData = combinedRows;
                renderTableFromData(currentData);
                renderChart(currentData, currentChartType);

                // Auto switch to chart view for aggregate
                if (currentChartType === 'table') {
                    switchView('bar'); // Default to bar for aggregate if currently table
                } else {
                    switchView(currentChartType);
                }

            } catch (e) {
                console.error(e);
                tableContainer.innerHTML = `<p style="color:red">Error loading aggregate data: ${e}</p>`;
            }
        }

        function processAndRender(csvText) {
            currentData = parseCSV(csvText);
            renderTableFromData(currentData);
            renderChart(currentData, currentChartType);
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return [];

            // We need to handle quotes nicely, so use regex or a simple parser
            // Reusing existing simple parser logic but returning array of lines (arrays)
            return lines.map(line => parseCSVRow(line));
        }

        function renderTableFromData(data) {
            if (!data || data.length === 0) {
                tableContainer.innerHTML = '<p>Empty data</p>';
                return;
            }

            const table = document.createElement('table');

            // Header
            const headers = data[0];
            const thead = document.createElement('thead');
            const trHead = document.createElement('tr');
            headers.forEach(h => {
                const th = document.createElement('th');
                th.textContent = h;
                trHead.appendChild(th);
            });
            thead.appendChild(trHead);
            table.appendChild(thead);

            // Body
            const tbody = document.createElement('tbody');
            // Limit to showing 500 rows to prevent crash on aggregate
            const maxRows = 500;
            const limit = Math.min(data.length, maxRows);

            for (let i = 1; i < limit; i++) {
                const tr = document.createElement('tr');
                const cols = data[i];
                cols.forEach(c => {
                    const td = document.createElement('td');
                    td.textContent = c;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            }
            if (data.length > maxRows) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = headers.length;
                td.textContent = `... and ${data.length - maxRows} more rows ...`;
                td.style.textAlign = "center";
                td.style.color = "#888";
                tr.appendChild(td);
                tbody.appendChild(tr);
            }

            table.appendChild(tbody);
            tableContainer.innerHTML = '';
            tableContainer.appendChild(table);
        }


        function switchMetric(val) {
            currentMetric = val;
            if (currentChartType !== 'table') {
                renderChart(currentData, currentChartType);
            }
        }

        // --- Visualization Logic ---

        function renderChart(data, type) {
            if (!data || data.length < 2) return;

            const headers = data[0];
            const rows = data.slice(1);

            // Accessors
            const idxFreq = headers.indexOf('frequencyId');
            const idxSSIM = headers.indexOf('targetSSIM');
            const idxCorrect = headers.indexOf('isCorrect');
            // Try to find response time column
            let idxRT = headers.indexOf('reactionTimeMs');
            if (idxRT === -1) idxRT = headers.indexOf('responseTime');
            if (idxRT === -1) idxRT = headers.indexOf('rt');
            if (idxRT === -1) idxRT = headers.indexOf('time');

            if (idxFreq === -1 || idxSSIM === -1 || idxCorrect === -1) {
                console.warn("Missing necessary columns for visualization");
                return;
            }

            const stats = {};
            let engagementCorrect = 0;
            let engagementTotal = 0;

            rows.forEach(row => {
                const freq = row[idxFreq];
                const ssim = row[idxSSIM];
                const correct = parseInt(row[idxCorrect]);
                const rt = idxRT !== -1 ? parseFloat(row[idxRT]) : 0;

                // Handle Engagement Checks (SSIM 0.95)
                if (Math.abs(parseFloat(ssim) - 0.95) < 0.0001) {
                    engagementTotal++;
                    if (correct === 1) engagementCorrect++;
                    return; // Skip from main chart
                }

                if (!stats[freq]) stats[freq] = {};
                if (!stats[freq][ssim]) stats[freq][ssim] = { correct: 0, total: 0, rtSum: 0 };

                stats[freq][ssim].correct += (correct === 1 ? 1 : 0);
                stats[freq][ssim].rtSum += (!isNaN(rt) ? rt : 0);
                stats[freq][ssim].total += 1;
            });

            // Update Engagement Stats UI
            const engStatsEl = document.getElementById('engagement-stats');
            if (engagementTotal > 0) {
                const engAcc = (engagementCorrect / engagementTotal * 100).toFixed(1);
                engStatsEl.textContent = `Engagement Check: ${engAcc}% (${engagementCorrect}/${engagementTotal})`;
                engStatsEl.style.color = (engAcc >= 80) ? '#2b8a3e' : '#e03131'; // Green or Red
            } else {
                engStatsEl.textContent = '';
            }

            // Prepare Chart Data
            // We want labels to be SSIM levels (numerically sorted)
            let allSSIMs = new Set();
            Object.values(stats).forEach(freqGroup => {
                Object.keys(freqGroup).forEach(s => allSSIMs.add(s));
            });

            // Sort numerically descending (High SSIM -> Low SSIM) i.e., Easy -> Hard
            // Or usually plots go Low -> High (Hard -> Easy).
            // Previous code was string sort reverse: "1.0", "0.9".
            // Let's do standard numeric sort descending to keep "1.0" at left if that's what it was,
            // or maybe user wants X-axis to be 0 -> 1.
            // "Target SSIM": 1.0 is reference, lower is more perturbed.
            // Usually X-axis is "Amount of Perturbation" or "SSIM".
            // If SSIM: 1.0 is max. 
            // Let's sort numerically ascending (0 -> 1). That is standard for axes.
            // Wait, previous code `sort().reverse()` on strings like "0.9", "0.75".
            // "0.9" vs "0.75"? "0.9" > "0.75". Reverse -> "0.9", "0.75" ...
            // Let's stick to Descending SSIM (1.0 -> 0.0) so it goes from "Reference" to "Distorted".
            // Or Ascending?
            // User likely wants consistent X-axis. 
            // Let's do Descending Numeric: 1.0, 0.95, ... 0.5.
            const labels = Array.from(allSSIMs).sort((a, b) => parseFloat(b) - parseFloat(a));

            const datasets = [];
            const colors = {
                'low': 'rgba(255, 127, 0)',   // Orange
                'medium': 'rgba(77, 175, 74)', // Green
                'high': 'rgba(55, 126, 184)'   // Blue
            };

            for (const freq of ['high', 'medium', 'low']) { // Order: Small, Medium, Large
                if (!stats[freq]) continue;

                const dataPoints = labels.map(ssim => {
                    const item = stats[freq][ssim];
                    if (!item) return 0;

                    if (currentMetric === 'accuracy') {
                        return (item.correct / item.total); // Rate 0-1
                    } else {
                        // Time
                        return item.total > 0 ? (item.rtSum / item.total) : 0;
                    }
                });

                const baseColor = colors[freq] || 'rgba(200, 200, 200)';

                const dataset = {
                    label: freq.toUpperCase() + ' Freq',
                    data: dataPoints,
                    borderColor: baseColor,
                    borderWidth: 2
                };

                if (type === 'line') {
                    dataset.backgroundColor = baseColor.replace(')', ', 0.1)'); // Transparent fill
                    dataset.fill = false; // No fill for clean lines
                    dataset.tension = 0.1; // Smooth lines
                    dataset.pointRadius = 4;
                } else {
                    // Bar settings
                    dataset.backgroundColor = baseColor.replace(')', ', 0.7)'); // 0.7 opacity
                    dataset.borderWidth = 1;
                }

                datasets.push(dataset);
            }

            // Add 62.5% Threshold Line (Only for Accuracy)
            if (currentMetric === 'accuracy') {
                const thresholdValue = 0.625;
                datasets.push({
                    type: 'line', // Mixed charts: line on top of bars
                    label: '62.5% Threshold',
                    data: Array(labels.length).fill(thresholdValue),
                    borderColor: 'rgba(0, 0, 0, 0.6)',
                    borderWidth: 2, // Thicker line
                    borderDash: [8, 8], // Longer dashes
                    pointRadius: 0,
                    fill: false,
                    order: 0 // Render on top
                });
            }

            // Create/Update Chart
            const ctx = document.getElementById('dataChart').getContext('2d');

            if (myChart) {
                myChart.destroy();
            }

            myChart = new Chart(ctx, {
                type: type,
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: currentMetric === 'accuracy' ? 1.0 : undefined,
                            title: {
                                display: true,
                                text: currentMetric === 'accuracy' ? 'Accuracy' : 'Avg Response Time (ms)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Target SSIM'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: currentMetric === 'accuracy' ? 'Accuracy by Frequency & SSIM' : 'Response Time by Frequency & SSIM'
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    if (currentMetric === 'accuracy') {
                                        return context.dataset.label + ': ' + (context.raw * 100).toFixed(1) + '%';
                                    } else {
                                        return context.dataset.label + ': ' + context.raw.toFixed(0) + ' ms';
                                    }
                                }
                            }
                        }
                    }
                }
            });
        }

        function switchView(viewName) {
            // Update buttons
            document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
            // Find the button for this view
            const btn = document.querySelector(`button[onclick="switchView('${viewName}')"]`);
            if (btn) btn.classList.add('active');

            if (viewName === 'table') {
                tableContainer.style.display = 'block';
                chartContainer.style.display = 'none';
                currentChartType = 'table';
            } else {
                // 'bar' or 'line'
                tableContainer.style.display = 'none';
                chartContainer.style.display = 'block';

                if (currentChartType !== viewName || !myChart) {
                    currentChartType = viewName;
                    renderChart(currentData, viewName);
                }
            }
        }

        // --- Utils ---

        // Simple CSV parser that handles quotes
        function parseCSVRow(row) {
            const result = [];
            let current = '';
            let inQuote = false;

            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                if (char === '"') {
                    inQuote = !inQuote;
                } else if (char === ',' && !inQuote) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result.map(s => s.replace(/^"|"$/g, '')); // Remove surrounding quotes
        }

        refreshBtn.onclick = fetchFileList;
        aggregateBtn.onclick = loadAllData;

        // Init
        fetchFileList();
    </script>
</body>

</html>